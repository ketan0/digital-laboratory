:PROPERTIES:
:ID:       1999996d-b676-4fc4-894b-caf82f8dd7ff
:END:
#+title: emacs

I started using Emacs in January 2020, and it has undoubtedly changed the way I do work on my computer, and the way I think about computing in general.

* Things I really like about emacs
** Emacs enables a personal framework of [[id:1096f874-fab2-4db1-88dc-b90740bf608a][experimentation]].
It's completely hackable, which easily leads to an "experimental" mindset. I feel like people don't really try tweaking the default settings of things in important ways. Granted, you can get lost in customization, and tweaking every little aesthetic and all that...but I believe that there have been several important ways that I've been able to customize my workflow due to Emacs and the OSS that has built many different extensions for it.
* Cool configs
** [[https://gitlab.com/justinekizhak/dotfiles/blob/master/emacs/doom.d/config.org][justinekizhak]]
I like the motivation he gives for why emacs is so damn cool. "Emacs changes how you /think/ about programming." I feel like this has been very true for me. It makes many other applications seem needlessly restrictive. It feels natural to have the entire OS be an introspectable operating system.
** [[https://github.com/larstvei/dot-emacs][larstvei]]
** [[https://github.com/danielmai/.emacs.d/blob/master/config.org][danielmai]]
** [[https://tecosaur.github.io/emacs-config/config.html][tecosaur]]
** [[https://github.com/jethrokuan/dots/blob/master/.doom.d/config.el][jethro]]
* skills I am learning
** become a master of [[id:2baa1991-e3c3-4b37-8703-296cda53a9a0][debugging]] in emacs
:PROPERTIES:
:ID:       d4ae4b67-706b-4977-9299-d3667eb940ed
:END:
Something crashing? Use [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][Edebug]] to debug it. Something slow? You can easily [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Profiling.html][profile]] it.
** lisp macros
Really powerful feature that allows one to define domain-specific syntax /within/ Emacs Lisp. Examples I really like include [[https://github.com/alphapapa/org-ql][org-ql]], [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Rx-Notation.html][rx notation]], and so many more that enable someone to write expressive, parsimonious code in a [[id:95ff3fb3-f886-41df-9f4f-5f9223b4ca4e][bottom-up]] fashion.


* Links to this node
:PROPERTIES:
:HTML_CONTAINER_CLASS: references
:END:
** [[id:e2ff4d71-a630-4a8d-94d4-66606f321bd4][musings]]

* Computation in brains must be deeply [[id:8d27adad-158b-4fa4-b31b-5f793d0b8341][context]]-aware.

** [[id:95ff3fb3-f886-41df-9f4f-5f9223b4ca4e][Programming Bottom-Up]]

http://www.paulgraham.com/progbot.html

There are two ways of [[id:0997b060-ee05-458e-beed-3494675c879d][programming]] in Lisp -- top-down, and bottom-up.

Top-down = the classic paradigm of divide-and conquer, decomposing the problem hierarchically into smaller problems.

Bottom-up = defining your own DSL in Lisp, and using those primitives to make something cool.

Most programming is done top-down, but with the powers of macros you can go bottom-up, creating "little universes" in Lisp...

Personally what comes to mind is the =rx= macro in emacs. It's like a nice little domain-specific language for writing regular expressions, embedded right into elisp.

Regexp matching a block comment in C:
#+begin_src emacs-lisp
(rx "/*"                          ; Initial /*
    (zero-or-more
     (or (not (any "*"))          ;  Either non-*,
         (seq "*"                 ;  or * followed by
              (not (any "/")))))  ;  non-/
    (one-or-more "*")             ; At least one star,
    "/")                          ; and the final /
#+end_src

#+RESULTS:
: /\*\(?:[^*]\|\*[^/]\)*\*+/

you redefine /the language itself/ to have the primitives you want it to have, and then you can proceed to build something (perhaps in top-down fashion now.) It's like "meeting in the middle," so you don't have to build up super complex primitives, and you don't have to decompose down to a super fine-grained level.

I wonder what the connection between this bottom-up paradigm and Bret Victor - The Future of Programming is. I feel like maybe there's an idea that his visual programming playgrounds are like a domain-specific language (albeit not in Lisp.) They give the user a powerful set of primitives to manipulate digital objects, and the user can then build from there to make it come to life.

Also feel like [[id:1999996d-b676-4fc4-894b-caf82f8dd7ff][emacs]] encourages bottom-up programming in some ways, well ofc because of Lisp, but also because of the interactivity of the environment. You write a snippet, and immediately you can evaluate that code and test out your snippet. You get a couple more snippets, try those out, and then it's like, ok cool, what else can I build with these snippets?
