<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-02 Wed 20:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Computer Networking</title>
<meta name="author" content="Ketan Agrawal" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="syntax.css" />
<link rel="stylesheet" type="text/css" href="styles.css" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
<link rel="manifest" href="/site.webmanifest" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<a style="color: inherit; text-decoration: none" href="/"><h2>Ketan's Nebula</h2></a>
</div>
<div id="content" class="content">
<h1 class="title">Computer Networking</h1>

<div id="outline-container-org2686ae5" class="outline-2">
<h2 id="org2686ae5">How does the <a href="internet.html#ID-b9d2d383-63a8-456b-afd2-4ca51b1b8825">Internet</a> work?</h2>
<div class="outline-text-2" id="text-org2686ae5">
</div>
<div id="outline-container-org487f2c6" class="outline-3">
<h3 id="org487f2c6">Internet Datagrams</h3>
<div class="outline-text-3" id="text-org487f2c6">
<p>
Datagrams (specific kinds of packets) contain the following elements:<br />
</p>

<ul class="org-ul">
<li>To address of a node (fully specified)<br /></li>
<li>text (~1 KB)<br /></li>
<li>From address of a node (fully specified)<br /></li>
</ul>
</div>
<div id="outline-container-org6c9c9e5" class="outline-4">
<h4 id="org6c9c9e5">The Internet is a system that tries its best to deliver datagrams.</h4>
<div class="outline-text-4" id="text-org6c9c9e5">
<p>
[my program] &lt;- [someone else&rsquo;s program]<br />
</p>

<p>
Everything is built on top of the abstraction of datagrams.<br />
</p>
</div>
</div>
<div id="outline-container-org1354015" class="outline-4">
<h4 id="org1354015">Things that could happen to datagrams:</h4>
<div class="outline-text-4" id="text-org1354015">
<ol class="org-ol">
<li>Delivered quickly<br /></li>
<li>Delivered, corrupted text<br /></li>
<li>Delivered, tampered text<br /></li>
<li>Delivered really late<br /></li>
<li>Delivered to/from wrong address<br /></li>
<li>Never delivered<br /></li>
<li>Delivered multiple times<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orgf13bc6e" class="outline-4">
<h4 id="orgf13bc6e">Key principle: Encapsulation</h4>
<div class="outline-text-4" id="text-orgf13bc6e">
<p>
Packets are like nested envelopes. Abstractions exist inside the packets as &ldquo;layers&rdquo; that only talk to the same &ldquo;layer.&rdquo; Each layer cares about a header of one of the nested envelopes. E.g., TCP cares about the TCP header. Routers examine the IP header. The kernel on a machine looks at the user datagram header, e.g. to decide which port (i.e. which application) to forward the packet to.<br />
</p>
</div>
</div>

<div id="outline-container-org36c8190" class="outline-4 references">
<h4 id="org36c8190">Links to this node</h4>
<div class="outline-text-4" id="text-org36c8190">
</div>
<ul class="org-ul">
<li><a id="org240f07d"></a><a href="#orga1165c0">Internet Protocol (IP)</a><br />
<div class="outline-text-5" id="text-org240f07d">
<p>
Everything in the internet is built on top of the Internet <a href="#org487f2c6">datagram</a> abstraction. Datagrams conform to the <a href="https://datatracker.ietf.org/doc/html/rfc791">Internet Protocol</a>. Within datagrams, the data can conform to a specific protocol, e.g. ICMP, TCP, UDP etc. Such protocol information is usually written in kernel space &#x2013; payload is determined by the application / user.<br />
</p>

<p>
The header is usually 24 bytes (well, no one uses the <code>Options</code> field, so 20 bytes):<br />
</p>
</div>
</li>

<li><a id="org2c5529c"></a><a href="#org4d435b0">Internet Datagram Header</a><br />
<ul class="org-ul">
<li><a id="org8f4852a"></a>(<i>Internet Protocol (IP) &gt; Internet Datagram Header</i>)<br />
<div class="outline-text-6" id="text-org8f4852a">
<p>
 0                   1                   2                   3<br />
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|Version​|  IHL  ​|Type of Service​|          Total Length         ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|         Identification        ​|Flags​|      Fragment Offset    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|  <a href="#orgb338d51">Time to Live</a> ​|    <a href="#orge283161">Protocol</a>   ​|         <a href="#orgc4a8ec4">Header Checksum</a>       ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                       Source Address                          ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Destination Address                        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Options                    ​|    Padding    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgca2cea0" class="outline-3">
<h3 id="orgca2cea0">How data finds its way across the internet</h3>
<div class="outline-text-3" id="text-orgca2cea0">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Data</td>
<td class="org-left">IP address</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org925babf" class="outline-3">
<h3 id="org925babf">IP addresses</h3>
<div class="outline-text-3" id="text-org925babf">
<p>
Every computer is given an address that&rsquo;s 32 bits* long. This is known as its IP address.<br />
</p>

<p>
IP addresses are a way to &ldquo;<a href="multiplexing.html#ID-e12d4dfd-b03b-4f84-bd5f-458dab82b2c5">multiplex</a>&rdquo; the scarce resource of the Internet &#x2013; multiple machines can communicate over the Internet, because routers know how to deliver packets based on their destination address.<br />
</p>

<p>
*Problem: only \(2^{32}\) = ~4 billion addresses in ipv4, which we have essentially run out of. Thus, ipv6 addresses were created that are 128 bits long.<br />
</p>

<p>
E.g. the IP address <code>104.196.238.229</code> simply represents a 32-bit number, separated into each of its 4 bytes.<br />
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(<span class="org-string">'{0:b}'</span>.<span class="org-builtin">format</span>((<span class="org-highlight-numbers-number">104</span> &lt;&lt; <span class="org-highlight-numbers-number">24</span>) + (<span class="org-highlight-numbers-number">196</span> &lt;&lt; <span class="org-highlight-numbers-number">16</span>) + (<span class="org-highlight-numbers-number">238</span> &lt;&lt; <span class="org-highlight-numbers-number">8</span>) + <span class="org-highlight-numbers-number">229</span>))
</pre>
</div>

<pre class="example">
1101000110001001110111011100101
</pre>


<p>
Here&rsquo;s <code>127.0.0.1</code>, aka <code>localhost</code>, in binary:<br />
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">print</span>(<span class="org-string">'{0:b}'</span>.<span class="org-builtin">format</span>((<span class="org-highlight-numbers-number">127</span> &lt;&lt; <span class="org-highlight-numbers-number">24</span>) + (<span class="org-highlight-numbers-number">0</span> &lt;&lt; <span class="org-highlight-numbers-number">16</span>) + (<span class="org-highlight-numbers-number">0</span> &lt;&lt; <span class="org-highlight-numbers-number">8</span>) + <span class="org-highlight-numbers-number">1</span>))
</pre>
</div>

<pre class="example">
1111111000000000000000000000001
</pre>
</div>
</div>
<div id="outline-container-orga6a8cc9" class="outline-3">
<h3 id="orga6a8cc9">Routers</h3>
<div class="outline-text-3" id="text-orga6a8cc9">
<p>
Routers forward packets <b>one at a time</b>. They look at IP addresses, and then send the packets to a router closer to the destination.<br />
</p>
</div>
</div>
<div id="outline-container-org9806c62" class="outline-3">
<h3 id="org9806c62">Modems</h3>
<div class="outline-text-3" id="text-org9806c62">
</div>

<div id="outline-container-org6f3298e" class="outline-4 references">
<h4 id="org6f3298e">Links to this node</h4>
<div class="outline-text-4" id="text-org6f3298e">
</div>
<ul class="org-ul">
<li><a id="orgb647e48"></a><a href="cs144_introduction_to_computer_networking.html#ID-9908ac8d-fadd-4fe6-a78c-c3471cc36ea1">Computer Networking</a><br />
<ul class="org-ul">
<li><a id="org4d0f808"></a>(<i>Evolution of the Internet &gt; Level 1: Home Modem</i>)<br />
<div class="outline-text-6" id="text-org4d0f808">
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">[</span>TCP/IP<span class="org-rainbow-delimiters-depth-1">]</span> computer--\                /--router - Google <span class="org-rainbow-delimiters-depth-1">(</span>e.g.<span class="org-rainbow-delimiters-depth-1">)</span>
                    \              /
                    modem ---- modem
</pre>
</div>
<p>
We have a pair of socket connected to each other. Sending each other internet datagrams <i>directly</i>.<br />
</p>

<p>
Socket addresses on home computer<br />
local: 18.241.0.5:53050<br />
peer: 172.217.0.36:50<br />
</p>

<p>
Socket addresses at Google:<br />
local: 172.217.0.36:50<br />
peer: 18.241.0.5:53050<br />
</p>

<p>
Totally fine to reuse the same local address, as long as each socket is connected to a different peer address.<br />
</p>

<p>
Problem:<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org7ef050e" class="outline-3">
<h3 id="org7ef050e">We can see the path our packets take.</h3>
<div class="outline-text-3" id="text-org7ef050e">
<div class="org-src-container">
<pre class="src src-bash">traceroute google.com
</pre>
</div>

<div class="org-src-container">
<pre class="src src-bash">ping yuba.stanford.edu -t <span class="org-highlight-numbers-number">10</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">PING</td>
<td class="org-left">yuba.stanford.edu</td>
<td class="org-left">(171.64.74.58):</td>
<td class="org-right">56</td>
<td class="org-left">data</td>
<td class="org-left">bytes</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=0</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=2.468</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=1</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=2.198</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=2</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=11.663</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=3</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=2.891</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=4</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=2.819</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=5</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=13.421</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=6</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=2.931</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=7</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=26.903</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=8</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=2.779</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-left">bytes</td>
<td class="org-left">from</td>
<td class="org-right">171.64.74.58:</td>
<td class="org-left">icmp<sub>seq</sub>=9</td>
<td class="org-left">ttl=61</td>
<td class="org-left">time=33.740</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">---</td>
<td class="org-left">yuba.stanford.edu</td>
<td class="org-left">ping</td>
<td class="org-right">statistics</td>
<td class="org-left">---</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">packets</td>
<td class="org-left">transmitted,</td>
<td class="org-right">10</td>
<td class="org-left">packets</td>
<td class="org-left">received,</td>
<td class="org-left">0.0%</td>
<td class="org-left">packet</td>
<td class="org-left">loss</td>
</tr>

<tr>
<td class="org-right">round-trip</td>
<td class="org-left">min/avg/max/stddev</td>
<td class="org-left">=</td>
<td class="org-right">2.198/10.181/33.740/10.887</td>
<td class="org-left">ms</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
TTL: time to live &#x2013; how long the packet has to reach its destination. if it expires, look at the FROM address, and tell the sender<br />
</p>
</div>
</div>
<div id="outline-container-org62194b6" class="outline-3">
<h3 id="org62194b6">Network Stack</h3>
<div class="outline-text-3" id="text-org62194b6">
</div>
<div id="outline-container-org4846a34" class="outline-4">
<h4 id="org4846a34">4 layer model</h4>
<div class="outline-text-4" id="text-org4846a34">
<p>
As an example&#x2026;imagine you open a webpage in Chrome. This is a high-level abstraction that gets translated down the network stack.<br />
</p>
<ul class="org-ul">
<li><b>Application Layer</b>: Chrome client makes a HTTP request, <code>GET index.html</code>.<br /></li>
<li><b>Transport Layer</b>: wraps the data in a TCP segment.<br /></li>
<li><b>Network Layer</b>: wraps the data in an Internet Datagram.<br /></li>
<li><b>Link Layer</b>: wraps the data in an Ethernet Frame.<br /></li>
</ul>

<p>
Then, this Ethernet frame gets sent through the network infrastructure, hop-by-hop, to its destination.<br />
</p>

<p>
At the destination, we receive an Ethernet frame, and the process proceeds in reverse:<br />
</p>
<ul class="org-ul">
<li><b>Link Layer</b>: Ethernet frame arrives.<br /></li>
<li><b>Network Layer</b>: get IP datagram out of the Ethernet frame.<br /></li>
<li><b>Transport Layer</b>: get TCP segment out of the IP datagram.<br /></li>
<li><b>Application Layer</b>: get HTTP request out of the TCP segment.<br /></li>
</ul>

<p>
The modularity of the stack is quite elegant/nice: there have been innovations at each layer, that don&rsquo;t affect the functionality of any of the other layers. This model is neither static nor all-encompassing: you can also insert other layers, e.g. TLS layer that encrypts the TCP byte stream! Proxies work at the HTTP level by forwarding everything through a proxy server, VPNs work at the datagram level (wrap a datagram in another datagram.)<br />
</p>
</div>
</div>
<div id="outline-container-org4945931" class="outline-4">
<h4 id="org4945931">More detailed</h4>
<div class="outline-text-4" id="text-org4945931">
<p>
Web page<br />
HTTP request / response<br />
Reliable byte stream<br />
Internet datagrams<br />
Ethernet frames<br />
Wave Packets<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb594781" class="outline-2">
<h2 id="orgb594781">Reliability (from unreliability)</h2>
<div class="outline-text-2" id="text-orgb594781">
</div>
<div id="outline-container-org4c1d7ec" class="outline-3">
<h3 id="org4c1d7ec">What the Internet provides</h3>
<div class="outline-text-3" id="text-org4c1d7ec">
<p>
The Internet provides best-effort delivery of datagrams, up to ~1.5KB.<br />
</p>

<p>
&ldquo;best-effort&rdquo; means the datagram might be:<br />
</p>
<ul class="org-ul">
<li>lost completely<br /></li>
<li>delivered more than once, out of order<br /></li>
<li>delivered with some bytes changed<br /></li>
<li>delivered but truncated.<br /></li>
</ul>
</div>
</div>
<div id="outline-container-orgc4df718" class="outline-3">
<h3 id="orgc4df718">What most users/applications want</h3>
<div class="outline-text-3" id="text-orgc4df718">
<p>
Users want reliability &#x2013; reliable retrieval of data, reliable action, reliable byte stream, reliable delivery of a large file, reliable remote procedure call<br />
</p>
</div>
</div>
<div id="outline-container-orgacff7b9" class="outline-3">
<h3 id="orgacff7b9">Reliability</h3>
<div class="outline-text-3" id="text-orgacff7b9">
<p>
A module behaves <b>reliably</b> when it:<br />
</p>
<ul class="org-ul">
<li>Provides some abstraction/interface<br /></li>
<li>Even in the face of underlying faults<br /></li>
<li>When it can&rsquo;t do that, it signals failure<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org859afa3" class="outline-3">
<h3 id="org859afa3">Big question: how to provide these abstractions reliably on top of an unreliable system?</h3>
<div class="outline-text-3" id="text-org859afa3">
<p>
We want to do <b>idempotent</b> operations; i.e. operations that have the same effect in the world, even if called multiple times / out of order.<br />
</p>

<p>
TCP in a nutshell:<br />
Byte stream 0..2 is &ldquo;A B C&rdquo;.<br />
Byte stream 4..6 is &ldquo;E F G&rdquo;.<br />
&ldquo;The next byte of the stream I need from you is #5&rdquo;.<br />
Byte stream ended at [index].<br />
</p>

<p>
^idempotent operations.<br />
</p>
</div>
</div>
</div>
<div id="outline-container-orga1165c0" class="outline-2">
<h2 id="orga1165c0">Internet Protocol (IP)</h2>
<div class="outline-text-2" id="text-orga1165c0">
<p>
Everything in the internet is built on top of the Internet <a href="#org487f2c6">datagram</a> abstraction. Datagrams conform to the <a href="https://datatracker.ietf.org/doc/html/rfc791">Internet Protocol</a>. Within datagrams, the data can conform to a specific protocol, e.g. ICMP, TCP, UDP etc. Such protocol information is usually written in kernel space &#x2013; payload is determined by the application / user.<br />
</p>

<p>
The header is usually 24 bytes (well, no one uses the <code>Options</code> field, so 20 bytes):<br />
</p>
</div>
<div id="outline-container-org4d435b0" class="outline-3 karabiner-keyboard-container dont-backlink-here">
<h3 id="org4d435b0">Internet <a href="#org487f2c6">Datagram</a> Header</h3>
<div class="outline-text-3" id="text-org4d435b0">
<p>
 0                   1                   2                   3<br />
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|Version​|  IHL  ​|Type of Service​|          Total Length         ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|         Identification        ​|Flags​|      Fragment Offset    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|  <a href="#orgb338d51">Time to Live</a> ​|    <a href="#orge283161">Protocol</a>   ​|         <a href="#orgc4a8ec4">Header Checksum</a>       ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                       Source Address                          ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Destination Address                        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Options                    ​|    Padding    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
</p>
</div>
</div>
<div id="outline-container-orgb338d51" class="outline-3">
<h3 id="orgb338d51">Time to Live (TTL)</h3>
<div class="outline-text-3" id="text-orgb338d51">
</div>
<div id="outline-container-orgec9751d" class="outline-4">
<h4 id="orgec9751d">Implementation of <code>traceroute</code> with TTL</h4>
</div>

<div id="outline-container-org14de62b" class="outline-4 references">
<h4 id="org14de62b">Links to this node</h4>
<div class="outline-text-4" id="text-org14de62b">
</div>
<ul class="org-ul">
<li><a id="orge87b12e"></a><a href="#org4d435b0">Internet Datagram Header</a><br />
<ul class="org-ul">
<li><a id="org691d4e9"></a>(<i>Internet Protocol (IP) &gt; Internet Datagram Header</i>)<br />
<div class="outline-text-6" id="text-org691d4e9">
<p>
 0                   1                   2                   3<br />
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|Version​|  IHL  ​|Type of Service​|          Total Length         ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|         Identification        ​|Flags​|      Fragment Offset    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|  <a href="#orgb338d51">Time to Live</a> ​|    <a href="#orge283161">Protocol</a>   ​|         <a href="#orgc4a8ec4">Header Checksum</a>       ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                       Source Address                          ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Destination Address                        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Options                    ​|    Padding    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="orgc630797"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="org7ed209d"></a>(<i>Transmission Control Protocol (TCP) &gt; Mechanisms in TCP that can combat the bad aspects of datagrams:</i>)<br />
<div class="outline-text-6" id="text-org7ed209d">
<ul class="org-ul">
<li>packet corruption &#x2013; <a href="#org3854292">checksum</a> ensures that the original data is intact.<br /></li>
<li>packet lost &#x2013; <a href="#orgb338d51">TTL</a> ensures that packets don&rsquo;t wander/cycle for too long, and a timeout triggers the packet to be resent.<br /></li>
<li>packet arrives more than once / out of order &#x2013; idempotence is ensured through the way that TCP keeps track of <a href="#org0599003">seqnos</a> of received data, and signals for the next sequence number using the <a href="#org6f4e130">ackno</a>.<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orge283161" class="outline-3">
<h3 id="orge283161">Protocol</h3>
<div class="outline-text-3" id="text-orge283161">
</div>

<div id="outline-container-org3fde062" class="outline-4 references">
<h4 id="org3fde062">Links to this node</h4>
<div class="outline-text-4" id="text-org3fde062">
</div>
<ul class="org-ul">
<li><a id="orgc8d5dfd"></a><a href="#org4d435b0">Internet Datagram Header</a><br />
<ul class="org-ul">
<li><a id="orge7d8eee"></a>(<i>Internet Protocol (IP) &gt; Internet Datagram Header</i>)<br />
<div class="outline-text-6" id="text-orge7d8eee">
<p>
 0                   1                   2                   3<br />
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|Version​|  IHL  ​|Type of Service​|          Total Length         ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|         Identification        ​|Flags​|      Fragment Offset    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|  <a href="#orgb338d51">Time to Live</a> ​|    <a href="#orge283161">Protocol</a>   ​|         <a href="#orgc4a8ec4">Header Checksum</a>       ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                       Source Address                          ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Destination Address                        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Options                    ​|    Padding    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="org066f52b"></a><a href="#org3548a4e">User Datagram Protocol (UDP)</a><br />
<div class="outline-text-5" id="text-org066f52b">
<p>
Problem: IP addresses only identify a machine. How does that machine know which application/program to deliver the packet to? We need another another layer of <a href="multiplexing.html#ID-e12d4dfd-b03b-4f84-bd5f-458dab82b2c5">multiplexing</a>, so that multiple applications on one computer can share one IP address.<br />
</p>

<p>
This is where UDP comes in&#x2013; we put something special, &ldquo;User Datagram Protocol&rdquo; (UDP) in the <a href="#orge283161">Protocol</a> field of the datagram header &#x2013; then in the UDP header, a <i>nested</i> header within the IP payload, a &ldquo;port&rdquo; that corresponds to a certain application. (<a href="#orgbe2121a">TCP</a> uses ports too!)<br />
</p>

<p>
Applications such as Zoom which may not need the strict ordering/reliability of TCP may use UDP to create a custom protocol. E.g. Zoom uses UDP to deliver their packets.<br />
</p>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgc4a8ec4" class="outline-3">
<h3 id="orgc4a8ec4">Header Checksum</h3>
<div class="outline-text-3" id="text-orgc4a8ec4">
</div>

<div id="outline-container-orgf745bc1" class="outline-4 references">
<h4 id="orgf745bc1">Links to this node</h4>
<div class="outline-text-4" id="text-orgf745bc1">
</div>
<ul class="org-ul">
<li><a id="orgdfa248e"></a><a href="#org4d435b0">Internet Datagram Header</a><br />
<ul class="org-ul">
<li><a id="org59bf5e4"></a>(<i>Internet Protocol (IP) &gt; Internet Datagram Header</i>)<br />
<div class="outline-text-6" id="text-org59bf5e4">
<p>
 0                   1                   2                   3<br />
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|Version​|  IHL  ​|Type of Service​|          Total Length         ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|         Identification        ​|Flags​|      Fragment Offset    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|  <a href="#orgb338d51">Time to Live</a> ​|    <a href="#orge283161">Protocol</a>   ​|         <a href="#orgc4a8ec4">Header Checksum</a>       ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                       Source Address                          ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Destination Address                        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Options                    ​|    Padding    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org32c3344" class="outline-3">
<h3 id="org32c3344">IP Payload</h3>
<div class="outline-text-3" id="text-org32c3344">
</div>
</div>
<div id="outline-container-orge61eed5" class="outline-3">
<h3 id="orge61eed5">IP addresses are hierarchical.</h3>
</div>
</div>
<div id="outline-container-orgbe2121a" class="outline-2">
<h2 id="orgbe2121a">Transmission Control Protocol (TCP)</h2>
<div class="outline-text-2" id="text-orgbe2121a">
<p>
TCP is a layer on top of Internet Datagrams, and it aims to fix the unreliability issues of the Internet by keeping track of which bytes have been received, and which bytes should be sent next.<br />
</p>

<p>
See <a href="https://www.ietf.org/rfc/rfc793.txt">https://www.ietf.org/rfc/rfc793.txt</a> for the full specification.<br />
</p>
</div>
<div id="outline-container-orga05f3d5" class="outline-3 karabiner-keyboard-container dont-show-content-in-backlinks">
<h3 id="orga05f3d5">TCP Header</h3>
<div class="outline-text-3" id="text-orga05f3d5">
<p>
0                   1                   2                   3<br />
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|          Source Port          ​|       Destination Port        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                        <a href="#org0599003">Sequence Number</a>                        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    <a href="#org6f4e130">Acknowledgment Number</a>                      ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|  Data ​|           ​|U​|<a href="#org60ff001">A</a>​|P​|R​|<a href="#orge795c68">S</a>​|<a href="#org3318745">F</a>​|                               ​|<br />
​| Offset​| Reserved  ​|R​|C​|S​|S​|Y​|I​|            Window             ​|<br />
​|       ​|           ​|G​|K​|H​|T​|N​|N​|                               ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|           <a href="#org3854292">Checksum</a>            ​|         Urgent Pointer        ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                    Options                    ​|    Padding    ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
​|                             data                              ​|<br />
+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​-+​<br />
</p>
</div>
</div>
<div id="outline-container-org0599003" class="outline-3">
<h3 id="org0599003">Sequence Number (seqno)</h3>
<div class="outline-text-3" id="text-org0599003">
</div>

<div id="outline-container-org25902e9" class="outline-4 references">
<h4 id="org25902e9">Links to this node</h4>
<div class="outline-text-4" id="text-org25902e9">
</div>
<ul class="org-ul">
<li><a id="org722bbd7"></a><a href="#orga05f3d5">TCP Header</a><br />
<ul class="org-ul">
<li><a id="org410cc7d"></a>(<i>Transmission Control Protocol (TCP) &gt; TCP Header</i>)<br /></li>
</ul>
</li>


<li><a id="orgf3b9f43"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="org5a8877a"></a>(<i>Transmission Control Protocol (TCP) &gt; Mechanisms in TCP that can combat the bad aspects of datagrams:</i>)<br />
<div class="outline-text-6" id="text-org5a8877a">
<ul class="org-ul">
<li>packet corruption &#x2013; <a href="#org3854292">checksum</a> ensures that the original data is intact.<br /></li>
<li>packet lost &#x2013; <a href="#orgb338d51">TTL</a> ensures that packets don&rsquo;t wander/cycle for too long, and a timeout triggers the packet to be resent.<br /></li>
<li>packet arrives more than once / out of order &#x2013; idempotence is ensured through the way that TCP keeps track of <a href="#org0599003">seqnos</a> of received data, and signals for the next sequence number using the <a href="#org6f4e130">ackno</a>.<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org6f4e130" class="outline-3">
<h3 id="org6f4e130">Acknowledgement Number (ackno)</h3>
<div class="outline-text-3" id="text-org6f4e130">
</div>

<div id="outline-container-org4606c88" class="outline-4 references">
<h4 id="org4606c88">Links to this node</h4>
<div class="outline-text-4" id="text-org4606c88">
</div>
<ul class="org-ul">
<li><a id="org53468fd"></a><a href="#orga05f3d5">TCP Header</a><br />
<ul class="org-ul">
<li><a id="org206d409"></a>(<i>Transmission Control Protocol (TCP) &gt; TCP Header</i>)<br /></li>
</ul>
</li>


<li><a id="orgacad0e2"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="org4a12fc1"></a>(<i>Transmission Control Protocol (TCP) &gt; Mechanisms in TCP that can combat the bad aspects of datagrams:</i>)<br />
<div class="outline-text-6" id="text-org4a12fc1">
<ul class="org-ul">
<li>packet corruption &#x2013; <a href="#org3854292">checksum</a> ensures that the original data is intact.<br /></li>
<li>packet lost &#x2013; <a href="#orgb338d51">TTL</a> ensures that packets don&rsquo;t wander/cycle for too long, and a timeout triggers the packet to be resent.<br /></li>
<li>packet arrives more than once / out of order &#x2013; idempotence is ensured through the way that TCP keeps track of <a href="#org0599003">seqnos</a> of received data, and signals for the next sequence number using the <a href="#org6f4e130">ackno</a>.<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org60ff001" class="outline-3">
<h3 id="org60ff001">ACK</h3>
<div class="outline-text-3" id="text-org60ff001">
</div>

<div id="outline-container-orgf14f29a" class="outline-4 references">
<h4 id="orgf14f29a">Links to this node</h4>
<div class="outline-text-4" id="text-orgf14f29a">
</div>
<ul class="org-ul">
<li><a id="org9f04d06"></a><a href="#orga05f3d5">TCP Header</a><br />
<ul class="org-ul">
<li><a id="orga80b472"></a>(<i>Transmission Control Protocol (TCP) &gt; TCP Header</i>)<br /></li>
</ul>
</li>


<li><a id="org4aee9b6"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="org6509751"></a>(<i>Transmission Control Protocol (TCP) &gt; Client/server 3-way handshake: SYN, SYN/ACK, ACK</i>)<br />
<div class="outline-text-6" id="text-org6509751">
<p>
In TCP, the two connectors to the byte stream are peers; they <i>both</i> can read/write from the bidirectional byte stream.<br />
</p>

<p>
That said &#x2013; there is a common pattern of usage of TCP, called the <b>client-server model.</b><br />
</p>

<p>
Client (Frankie):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"0"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this "binds" the socket to a local address: IP address and port number</span>
sock.listen<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">"listen" for incoming connections on this socket</span>
</pre>
</div>

<p>
Server (Keith):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.connect<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"[frankie's remote IP address]"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">//</span><span class="org-comment">Connect to Frankie's IP address on port 3</span>
</pre>
</div>

<p>
This is known as the <b>TCP 3-way handshake</b>:<br />
</p>
<ul class="org-ul">
<li><code>sock.connect</code> is where the first bytes get sent &#x2013; Keith sends a TCP segment with <a href="#orge795c68">SYN</a> flag set 1 to start the server =&gt; client stream. This initiates the connection.<br /></li>
<li>Frankie responds to Keith with a <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> segment, simultaneously acknowledging Keith&rsquo;s SYN bit and starting a client =&gt; server stream with the new SYN.<br /></li>
<li>Keith responds to Frankie&rsquo;s <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> with another ACK (to acknowledge Frankie&rsquo;s SYN.)<br /></li>
</ul>

<p>
Note: Frankie can &ldquo;accept&rdquo; the connection:<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock_connected</span> = sock.accept<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
Note &#x2013; this is not the only way a connection can be established! TCP&rsquo;s rules are more general than that:<br />
</p>
<ul class="org-ul">
<li>Every stream sends: SYN, bytes, FIN<br /></li>
<li>Each byte, SYN, and FIN occupy 1 sequence number each<br /></li>
<li>Each segment that occupies a sequence number provokes an acknowledgment<br /></li>
</ul>

<p>
This is fundamentally symmetrical: no reason why one peer has to initiate, and the other has to accept. Here&rsquo;s a more symmetrical way of establishing connection:<br />
</p>
<ul class="org-ul">
<li>Peers both send SYN segments (initiating at the same time)<br /></li>
<li>Peers receive these SYN segments and send ACK segments<br /></li>
</ul>
<p>
I.e.: If Frankie and Keith are both bound to a port number, and they both want to connect to each other at the same time, they can both call <code>connect</code> on each others&rsquo; IP address + port. Calling <code>connect</code> results in a SYN flag being sent<br />
</p>

<p>
Could consider this &ldquo;4-way handshake&rdquo;: SYN, SYN, ACK, ACK. 99% of connections do 3-way handshake, but this is just because of the reality that the vast majority of connections on the Internet are between client and server.<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="org0d6ed81"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="org9391df7"></a>(<i>Transmission Control Protocol (TCP) &gt; Client/server 3-way handshake: SYN, SYN/ACK, ACK</i>)<br />
<div class="outline-text-6" id="text-org9391df7">
<p>
In TCP, the two connectors to the byte stream are peers; they <i>both</i> can read/write from the bidirectional byte stream.<br />
</p>

<p>
That said &#x2013; there is a common pattern of usage of TCP, called the <b>client-server model.</b><br />
</p>

<p>
Client (Frankie):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"0"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this "binds" the socket to a local address: IP address and port number</span>
sock.listen<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">"listen" for incoming connections on this socket</span>
</pre>
</div>

<p>
Server (Keith):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.connect<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"[frankie's remote IP address]"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">//</span><span class="org-comment">Connect to Frankie's IP address on port 3</span>
</pre>
</div>

<p>
This is known as the <b>TCP 3-way handshake</b>:<br />
</p>
<ul class="org-ul">
<li><code>sock.connect</code> is where the first bytes get sent &#x2013; Keith sends a TCP segment with <a href="#orge795c68">SYN</a> flag set 1 to start the server =&gt; client stream. This initiates the connection.<br /></li>
<li>Frankie responds to Keith with a <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> segment, simultaneously acknowledging Keith&rsquo;s SYN bit and starting a client =&gt; server stream with the new SYN.<br /></li>
<li>Keith responds to Frankie&rsquo;s <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> with another ACK (to acknowledge Frankie&rsquo;s SYN.)<br /></li>
</ul>

<p>
Note: Frankie can &ldquo;accept&rdquo; the connection:<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock_connected</span> = sock.accept<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
Note &#x2013; this is not the only way a connection can be established! TCP&rsquo;s rules are more general than that:<br />
</p>
<ul class="org-ul">
<li>Every stream sends: SYN, bytes, FIN<br /></li>
<li>Each byte, SYN, and FIN occupy 1 sequence number each<br /></li>
<li>Each segment that occupies a sequence number provokes an acknowledgment<br /></li>
</ul>

<p>
This is fundamentally symmetrical: no reason why one peer has to initiate, and the other has to accept. Here&rsquo;s a more symmetrical way of establishing connection:<br />
</p>
<ul class="org-ul">
<li>Peers both send SYN segments (initiating at the same time)<br /></li>
<li>Peers receive these SYN segments and send ACK segments<br /></li>
</ul>
<p>
I.e.: If Frankie and Keith are both bound to a port number, and they both want to connect to each other at the same time, they can both call <code>connect</code> on each others&rsquo; IP address + port. Calling <code>connect</code> results in a SYN flag being sent<br />
</p>

<p>
Could consider this &ldquo;4-way handshake&rdquo;: SYN, SYN, ACK, ACK. 99% of connections do 3-way handshake, but this is just because of the reality that the vast majority of connections on the Internet are between client and server.<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orge795c68" class="outline-3">
<h3 id="orge795c68">SYN</h3>
<div class="outline-text-3" id="text-orge795c68">
</div>

<div id="outline-container-orgcf50de7" class="outline-4 references">
<h4 id="orgcf50de7">Links to this node</h4>
<div class="outline-text-4" id="text-orgcf50de7">
</div>
<ul class="org-ul">
<li><a id="orga41e151"></a><a href="#orga05f3d5">TCP Header</a><br />
<ul class="org-ul">
<li><a id="org52843c4"></a>(<i>Transmission Control Protocol (TCP) &gt; TCP Header</i>)<br /></li>
</ul>
</li>


<li><a id="org1ac500f"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="org6587912"></a>(<i>Transmission Control Protocol (TCP) &gt; Client/server 3-way handshake: SYN, SYN/ACK, ACK</i>)<br />
<div class="outline-text-6" id="text-org6587912">
<p>
In TCP, the two connectors to the byte stream are peers; they <i>both</i> can read/write from the bidirectional byte stream.<br />
</p>

<p>
That said &#x2013; there is a common pattern of usage of TCP, called the <b>client-server model.</b><br />
</p>

<p>
Client (Frankie):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"0"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this "binds" the socket to a local address: IP address and port number</span>
sock.listen<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">"listen" for incoming connections on this socket</span>
</pre>
</div>

<p>
Server (Keith):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.connect<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"[frankie's remote IP address]"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">//</span><span class="org-comment">Connect to Frankie's IP address on port 3</span>
</pre>
</div>

<p>
This is known as the <b>TCP 3-way handshake</b>:<br />
</p>
<ul class="org-ul">
<li><code>sock.connect</code> is where the first bytes get sent &#x2013; Keith sends a TCP segment with <a href="#orge795c68">SYN</a> flag set 1 to start the server =&gt; client stream. This initiates the connection.<br /></li>
<li>Frankie responds to Keith with a <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> segment, simultaneously acknowledging Keith&rsquo;s SYN bit and starting a client =&gt; server stream with the new SYN.<br /></li>
<li>Keith responds to Frankie&rsquo;s <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> with another ACK (to acknowledge Frankie&rsquo;s SYN.)<br /></li>
</ul>

<p>
Note: Frankie can &ldquo;accept&rdquo; the connection:<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock_connected</span> = sock.accept<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
Note &#x2013; this is not the only way a connection can be established! TCP&rsquo;s rules are more general than that:<br />
</p>
<ul class="org-ul">
<li>Every stream sends: SYN, bytes, FIN<br /></li>
<li>Each byte, SYN, and FIN occupy 1 sequence number each<br /></li>
<li>Each segment that occupies a sequence number provokes an acknowledgment<br /></li>
</ul>

<p>
This is fundamentally symmetrical: no reason why one peer has to initiate, and the other has to accept. Here&rsquo;s a more symmetrical way of establishing connection:<br />
</p>
<ul class="org-ul">
<li>Peers both send SYN segments (initiating at the same time)<br /></li>
<li>Peers receive these SYN segments and send ACK segments<br /></li>
</ul>
<p>
I.e.: If Frankie and Keith are both bound to a port number, and they both want to connect to each other at the same time, they can both call <code>connect</code> on each others&rsquo; IP address + port. Calling <code>connect</code> results in a SYN flag being sent<br />
</p>

<p>
Could consider this &ldquo;4-way handshake&rdquo;: SYN, SYN, ACK, ACK. 99% of connections do 3-way handshake, but this is just because of the reality that the vast majority of connections on the Internet are between client and server.<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="org346ca05"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="org21f8920"></a>(<i>Transmission Control Protocol (TCP) &gt; Client/server 3-way handshake: SYN, SYN/ACK, ACK</i>)<br />
<div class="outline-text-6" id="text-org21f8920">
<p>
In TCP, the two connectors to the byte stream are peers; they <i>both</i> can read/write from the bidirectional byte stream.<br />
</p>

<p>
That said &#x2013; there is a common pattern of usage of TCP, called the <b>client-server model.</b><br />
</p>

<p>
Client (Frankie):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"0"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this "binds" the socket to a local address: IP address and port number</span>
sock.listen<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">"listen" for incoming connections on this socket</span>
</pre>
</div>

<p>
Server (Keith):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.connect<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"[frankie's remote IP address]"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">//</span><span class="org-comment">Connect to Frankie's IP address on port 3</span>
</pre>
</div>

<p>
This is known as the <b>TCP 3-way handshake</b>:<br />
</p>
<ul class="org-ul">
<li><code>sock.connect</code> is where the first bytes get sent &#x2013; Keith sends a TCP segment with <a href="#orge795c68">SYN</a> flag set 1 to start the server =&gt; client stream. This initiates the connection.<br /></li>
<li>Frankie responds to Keith with a <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> segment, simultaneously acknowledging Keith&rsquo;s SYN bit and starting a client =&gt; server stream with the new SYN.<br /></li>
<li>Keith responds to Frankie&rsquo;s <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> with another ACK (to acknowledge Frankie&rsquo;s SYN.)<br /></li>
</ul>

<p>
Note: Frankie can &ldquo;accept&rdquo; the connection:<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock_connected</span> = sock.accept<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
Note &#x2013; this is not the only way a connection can be established! TCP&rsquo;s rules are more general than that:<br />
</p>
<ul class="org-ul">
<li>Every stream sends: SYN, bytes, FIN<br /></li>
<li>Each byte, SYN, and FIN occupy 1 sequence number each<br /></li>
<li>Each segment that occupies a sequence number provokes an acknowledgment<br /></li>
</ul>

<p>
This is fundamentally symmetrical: no reason why one peer has to initiate, and the other has to accept. Here&rsquo;s a more symmetrical way of establishing connection:<br />
</p>
<ul class="org-ul">
<li>Peers both send SYN segments (initiating at the same time)<br /></li>
<li>Peers receive these SYN segments and send ACK segments<br /></li>
</ul>
<p>
I.e.: If Frankie and Keith are both bound to a port number, and they both want to connect to each other at the same time, they can both call <code>connect</code> on each others&rsquo; IP address + port. Calling <code>connect</code> results in a SYN flag being sent<br />
</p>

<p>
Could consider this &ldquo;4-way handshake&rdquo;: SYN, SYN, ACK, ACK. 99% of connections do 3-way handshake, but this is just because of the reality that the vast majority of connections on the Internet are between client and server.<br />
</p>
</div>
</li>
</ul>
</li>

<li><a id="org1dae1b7"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="orge6311ca"></a>(<i>Transmission Control Protocol (TCP) &gt; Client/server 3-way handshake: SYN, SYN/ACK, ACK</i>)<br />
<div class="outline-text-6" id="text-orge6311ca">
<p>
In TCP, the two connectors to the byte stream are peers; they <i>both</i> can read/write from the bidirectional byte stream.<br />
</p>

<p>
That said &#x2013; there is a common pattern of usage of TCP, called the <b>client-server model.</b><br />
</p>

<p>
Client (Frankie):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"0"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this "binds" the socket to a local address: IP address and port number</span>
sock.listen<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">"listen" for incoming connections on this socket</span>
</pre>
</div>

<p>
Server (Keith):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.connect<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"[frankie's remote IP address]"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">//</span><span class="org-comment">Connect to Frankie's IP address on port 3</span>
</pre>
</div>

<p>
This is known as the <b>TCP 3-way handshake</b>:<br />
</p>
<ul class="org-ul">
<li><code>sock.connect</code> is where the first bytes get sent &#x2013; Keith sends a TCP segment with <a href="#orge795c68">SYN</a> flag set 1 to start the server =&gt; client stream. This initiates the connection.<br /></li>
<li>Frankie responds to Keith with a <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> segment, simultaneously acknowledging Keith&rsquo;s SYN bit and starting a client =&gt; server stream with the new SYN.<br /></li>
<li>Keith responds to Frankie&rsquo;s <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> with another ACK (to acknowledge Frankie&rsquo;s SYN.)<br /></li>
</ul>

<p>
Note: Frankie can &ldquo;accept&rdquo; the connection:<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock_connected</span> = sock.accept<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
Note &#x2013; this is not the only way a connection can be established! TCP&rsquo;s rules are more general than that:<br />
</p>
<ul class="org-ul">
<li>Every stream sends: SYN, bytes, FIN<br /></li>
<li>Each byte, SYN, and FIN occupy 1 sequence number each<br /></li>
<li>Each segment that occupies a sequence number provokes an acknowledgment<br /></li>
</ul>

<p>
This is fundamentally symmetrical: no reason why one peer has to initiate, and the other has to accept. Here&rsquo;s a more symmetrical way of establishing connection:<br />
</p>
<ul class="org-ul">
<li>Peers both send SYN segments (initiating at the same time)<br /></li>
<li>Peers receive these SYN segments and send ACK segments<br /></li>
</ul>
<p>
I.e.: If Frankie and Keith are both bound to a port number, and they both want to connect to each other at the same time, they can both call <code>connect</code> on each others&rsquo; IP address + port. Calling <code>connect</code> results in a SYN flag being sent<br />
</p>

<p>
Could consider this &ldquo;4-way handshake&rdquo;: SYN, SYN, ACK, ACK. 99% of connections do 3-way handshake, but this is just because of the reality that the vast majority of connections on the Internet are between client and server.<br />
</p>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org3318745" class="outline-3">
<h3 id="org3318745">FIN</h3>
<div class="outline-text-3" id="text-org3318745">
</div>

<div id="outline-container-org2ed5b43" class="outline-4 references">
<h4 id="org2ed5b43">Links to this node</h4>
<div class="outline-text-4" id="text-org2ed5b43">
</div>
<ul class="org-ul">
<li><a id="orge71474c"></a><a href="#orga05f3d5">TCP Header</a><br />
<ul class="org-ul">
<li><a id="org2f181f2"></a>(<i>Transmission Control Protocol (TCP) &gt; TCP Header</i>)<br /></li>
</ul>
</li>
</ul>
</div>
</div>



<div id="outline-container-org3854292" class="outline-3">
<h3 id="org3854292">Checksum</h3>
<div class="outline-text-3" id="text-org3854292">
</div>

<div id="outline-container-org3a86139" class="outline-4 references">
<h4 id="org3a86139">Links to this node</h4>
<div class="outline-text-4" id="text-org3a86139">
</div>
<ul class="org-ul">
<li><a id="org42d74e8"></a><a href="#orga05f3d5">TCP Header</a><br />
<ul class="org-ul">
<li><a id="org23f4625"></a>(<i>Transmission Control Protocol (TCP) &gt; TCP Header</i>)<br /></li>
</ul>
</li>


<li><a id="org7a8b706"></a><a href="#orgbe2121a">Transmission Control Protocol (TCP)</a><br />
<ul class="org-ul">
<li><a id="orgbb3e5a5"></a>(<i>Transmission Control Protocol (TCP) &gt; Mechanisms in TCP that can combat the bad aspects of datagrams:</i>)<br />
<div class="outline-text-6" id="text-orgbb3e5a5">
<ul class="org-ul">
<li>packet corruption &#x2013; <a href="#org3854292">checksum</a> ensures that the original data is intact.<br /></li>
<li>packet lost &#x2013; <a href="#orgb338d51">TTL</a> ensures that packets don&rsquo;t wander/cycle for too long, and a timeout triggers the packet to be resent.<br /></li>
<li>packet arrives more than once / out of order &#x2013; idempotence is ensured through the way that TCP keeps track of <a href="#org0599003">seqnos</a> of received data, and signals for the next sequence number using the <a href="#org6f4e130">ackno</a>.<br /></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgc1848c9" class="outline-3">
<h3 id="orgc1848c9">Client/server 3-way handshake: SYN, SYN/ACK, ACK</h3>
<div class="outline-text-3" id="text-orgc1848c9">
<p>
In TCP, the two connectors to the byte stream are peers; they <i>both</i> can read/write from the bidirectional byte stream.<br />
</p>

<p>
That said &#x2013; there is a common pattern of usage of TCP, called the <b>client-server model.</b><br />
</p>

<p>
Client (Frankie):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"0"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">this "binds" the socket to a local address: IP address and port number</span>
sock.listen<span class="org-rainbow-delimiters-depth-1">()</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">"listen" for incoming connections on this socket</span>
</pre>
</div>

<p>
Server (Keith):<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock</span>;
sock.connect<span class="org-rainbow-delimiters-depth-1">(</span> <span class="org-rainbow-delimiters-depth-2">{</span><span class="org-string">"[frankie's remote IP address]"</span>, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">}</span> <span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment-delimiter">//</span><span class="org-comment">Connect to Frankie's IP address on port 3</span>
</pre>
</div>

<p>
This is known as the <b>TCP 3-way handshake</b>:<br />
</p>
<ul class="org-ul">
<li><code>sock.connect</code> is where the first bytes get sent &#x2013; Keith sends a TCP segment with <a href="#orge795c68">SYN</a> flag set 1 to start the server =&gt; client stream. This initiates the connection.<br /></li>
<li>Frankie responds to Keith with a <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> segment, simultaneously acknowledging Keith&rsquo;s SYN bit and starting a client =&gt; server stream with the new SYN.<br /></li>
<li>Keith responds to Frankie&rsquo;s <a href="#orge795c68">SYN</a>/<a href="#org60ff001">ACK</a> with another ACK (to acknowledge Frankie&rsquo;s SYN.)<br /></li>
</ul>

<p>
Note: Frankie can &ldquo;accept&rdquo; the connection:<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="org-type">TCPSocket</span> <span class="org-variable-name">sock_connected</span> = sock.accept<span class="org-rainbow-delimiters-depth-1">()</span>;
</pre>
</div>

<p>
Note &#x2013; this is not the only way a connection can be established! TCP&rsquo;s rules are more general than that:<br />
</p>
<ul class="org-ul">
<li>Every stream sends: SYN, bytes, FIN<br /></li>
<li>Each byte, SYN, and FIN occupy 1 sequence number each<br /></li>
<li>Each segment that occupies a sequence number provokes an acknowledgment<br /></li>
</ul>

<p>
This is fundamentally symmetrical: no reason why one peer has to initiate, and the other has to accept. Here&rsquo;s a more symmetrical way of establishing connection:<br />
</p>
<ul class="org-ul">
<li>Peers both send SYN segments (initiating at the same time)<br /></li>
<li>Peers receive these SYN segments and send ACK segments<br /></li>
</ul>
<p>
I.e.: If Frankie and Keith are both bound to a port number, and they both want to connect to each other at the same time, they can both call <code>connect</code> on each others&rsquo; IP address + port. Calling <code>connect</code> results in a SYN flag being sent<br />
</p>

<p>
Could consider this &ldquo;4-way handshake&rdquo;: SYN, SYN, ACK, ACK. 99% of connections do 3-way handshake, but this is just because of the reality that the vast majority of connections on the Internet are between client and server.<br />
</p>
</div>
</div>
<div id="outline-container-orge05be7a" class="outline-3">
<h3 id="orge05be7a">Mechanisms in TCP that can combat the bad aspects of datagrams:</h3>
<div class="outline-text-3" id="text-orge05be7a">
<ul class="org-ul">
<li>packet corruption &#x2013; <a href="#org3854292">checksum</a> ensures that the original data is intact.<br /></li>
<li>packet lost &#x2013; <a href="#orgb338d51">TTL</a> ensures that packets don&rsquo;t wander/cycle for too long, and a timeout triggers the packet to be resent.<br /></li>
<li>packet arrives more than once / out of order &#x2013; idempotence is ensured through the way that TCP keeps track of <a href="#org0599003">seqnos</a> of received data, and signals for the next sequence number using the <a href="#org6f4e130">ackno</a>.<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgcd6c3ab" class="outline-3 references">
<h3 id="orgcd6c3ab">Links to this node</h3>
<div class="outline-text-3" id="text-orgcd6c3ab">
</div>
<div id="outline-container-org63b6f46" class="outline-4">
<h4 id="org63b6f46"><a href="#org3548a4e">User Datagram Protocol (UDP)</a></h4>
<div class="outline-text-4" id="text-org63b6f46">
<p>
Problem: IP addresses only identify a machine. How does that machine know which application/program to deliver the packet to? We need another another layer of <a href="multiplexing.html#ID-e12d4dfd-b03b-4f84-bd5f-458dab82b2c5">multiplexing</a>, so that multiple applications on one computer can share one IP address.<br />
</p>

<p>
This is where UDP comes in&#x2013; we put something special, &ldquo;User Datagram Protocol&rdquo; (UDP) in the <a href="#orge283161">Protocol</a> field of the datagram header &#x2013; then in the UDP header, a <i>nested</i> header within the IP payload, a &ldquo;port&rdquo; that corresponds to a certain application. (<a href="#orgbe2121a">TCP</a> uses ports too!)<br />
</p>

<p>
Applications such as Zoom which may not need the strict ordering/reliability of TCP may use UDP to create a custom protocol. E.g. Zoom uses UDP to deliver their packets.<br />
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org3548a4e" class="outline-2">
<h2 id="org3548a4e">User Datagram Protocol (UDP)</h2>
<div class="outline-text-2" id="text-org3548a4e">
<p>
Problem: IP addresses only identify a machine. How does that machine know which application/program to deliver the packet to? We need another another layer of <a href="multiplexing.html#ID-e12d4dfd-b03b-4f84-bd5f-458dab82b2c5">multiplexing</a>, so that multiple applications on one computer can share one IP address.<br />
</p>

<p>
This is where UDP comes in&#x2013; we put something special, &ldquo;User Datagram Protocol&rdquo; (UDP) in the <a href="#orge283161">Protocol</a> field of the datagram header &#x2013; then in the UDP header, a <i>nested</i> header within the IP payload, a &ldquo;port&rdquo; that corresponds to a certain application. (<a href="#orgbe2121a">TCP</a> uses ports too!)<br />
</p>

<p>
Applications such as Zoom which may not need the strict ordering/reliability of TCP may use UDP to create a custom protocol. E.g. Zoom uses UDP to deliver their packets.<br />
</p>
</div>
</div>
<div id="outline-container-org81149c1" class="outline-2">
<h2 id="org81149c1">Domain Name System (DNS)</h2>
<div class="outline-text-2" id="text-org81149c1">
<p>
Have to ask Domain Name Servers to convert a domain name to an IP address.<br />
</p>

<p>
Internet Datagram contains User Datagram. User Datagram contains Domain Name System lookup / response<br />
</p>
</div>

<div id="outline-container-org8403859" class="outline-3">
<h3 id="org8403859">How does DNS work from the client side?</h3>
<div class="outline-text-3" id="text-org8403859">
<p>
A <i>DNS request</i> is a request for a hostname-to-IP address mapping. E.g., &ldquo;tell me the IP address for tiktok.com.&rdquo;<br />
</p>

<p>
A client sends a DNS request to a DNS server &#x2013; client has a list of DNS server addresses in `etc/resolve.conf`.<br />
</p>

<p>
The DNS request is encapsulated in a <b>user datagram</b>, which is in turn encapsulated in an <b>IP (Internet) datagram</b>. It&rsquo;s often said &ldquo;DNS runs over UDP&rdquo; &#x2013; this means that DNS uses UDP as its transport protocol.<br />
</p>
</div>
</div>
<div id="outline-container-org49e3fd8" class="outline-3">
<h3 id="org49e3fd8">How do names get assigned?</h3>
<div class="outline-text-3" id="text-org49e3fd8">
<p>
DNS hierarchy has a single domain at the top of the structure: the <b>root domain</b> (.)<br />
</p>

<p>
Below this are the <b>top-level domains</b> (TLD): .com, .edu, .gov, .mil, .org, .net, .int.<br />
</p>

<p>
Domains under the TLDs represent individual organizations or entities, e.g. Stanford (<code>stanford.edu</code>.) Certain organizations have domain delegation, which means that their network admin maintains the DNS database for that domain.<br />
</p>
</div>
</div>

<div id="outline-container-org26df3af" class="outline-3">
<h3 id="org26df3af">How do we do DNS lookup?</h3>
<div class="outline-text-3" id="text-org26df3af">
<p>
Can lookup the domain name through a recursive process, descending down the DNS hierarchy.<br />
</p>
<ul class="org-ul">
<li>First, we asked the root name server for &ldquo;puffer.stanford.edu.&rdquo;<br />
<ul class="org-ul">
<li>The root name server said, &ldquo;we don&rsquo;t know anything about &rdquo;puffer.stanford.edu.&ldquo;, but we do know the IP addresses of the name servers that have information about names with &rdquo;.edu&ldquo; suffixes<br /></li>
</ul></li>
<li>Then, we asked one of those &ldquo;.edu&rdquo; servers for the IP address of &ldquo;puffer.stanford.edu.&rdquo;<br />
<ul class="org-ul">
<li>This server said, &ldquo;we don&rsquo;t know anything about &rdquo;puffer.stanford.edu.&ldquo;, but we do know the IP addresses of the servers that have information about names with &rdquo;stanford.edu&ldquo; suffixes<br /></li>
</ul></li>
<li>So, we asked one of those servers, and we got the IP address of &ldquo;puffer.stanford.edu.&rdquo;<br /></li>
</ul>

<p>
That said &#x2013; that&rsquo;s probably not what your computer does. DNS lookup tables are cached at many levels (even on the computer itself.)<br />
</p>
</div>
</div>
<div id="outline-container-org0a6d6d1" class="outline-3">
<h3 id="org0a6d6d1">Who stores name =&gt; IP address mappings?</h3>
<div class="outline-text-3" id="text-org0a6d6d1">
<p>
Ask the root name server for puffer.stanford.edu. DNS servers cache things.<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org95d8e2e" class="outline-2">
<h2 id="org95d8e2e">Packet Switching</h2>
<div class="outline-text-2" id="text-org95d8e2e">
</div>
<div id="outline-container-org8a27c7e" class="outline-3">
<h3 id="org8a27c7e">Old way of networking: circuit switching</h3>
<div class="outline-text-3" id="text-org8a27c7e">
<pre class="example" id="orgab38341">
Person 1                               Person 3
        \                             /
        [Palo Alto] --------- [Austin]
        /                             \
Person 2                               Person 4
</pre>

<p>
If too many people are on the &ldquo;trunk&rdquo; connection, it says the line is full.<br />
</p>

<p>
Bad: this kind of network is locking us into one paradigm &#x2013; phone calls. Also, other kinds of communications (e.g. email) don&rsquo;t need to use the connection for long periods of time. This is inefficient.<br />
</p>
</div>
</div>

<div id="outline-container-orgbebbb63" class="outline-3">
<h3 id="orgbebbb63">New way of networking: packet switching</h3>
<div class="outline-text-3" id="text-orgbebbb63">
<p>
Routers just handle packets. They don&rsquo;t need circuits, reservations, permissions, etc. Don&rsquo;t know anything about the contents of the packets &#x2013; just datagrams being passed along.<br />
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Header</td>
<td class="org-left">Payload</td>
</tr>
</tbody>
</table>

<p>
Phone calls can happen over the internet &#x2013; just packets flying around. Voice ove Internet Protocol (VoIP).<br />
</p>

<p>
<i>Question: is there historical similarity between the phone networks and computer networks?</i><br />
</p>


<div id="org9132daa" class="figure">
<p><img src="packetswitching.png" alt="packetswitching.png" /><br />
</p>
</div>
</div>
</div>
<div id="outline-container-org089231d" class="outline-3">
<h3 id="org089231d">Packet switches have buffers</h3>
<div class="outline-text-3" id="text-org089231d">
<p>
We want this infrastructure to constantly be in <i>use</i>. This necessitates a &ldquo;queue&rdquo; of packets waiting to be sent.<br />
</p>
<pre class="example" id="orgfac6435">
A
 \
  [Router]
 /
B
</pre>
</div>
</div>
<div id="outline-container-orgc0b8009" class="outline-3">
<h3 id="orgc0b8009">Serialization / Packetization delay</h3>
<div class="outline-text-3" id="text-orgc0b8009">
<p>
A <a href="edges.html#ID-993f765f-4385-4fcc-a5f6-de5f9a3360ad">link</a> is a connection between two <a href="nodes.html#ID-01d1ebb2-467c-4d3e-80c4-879429ccf9b6">nodes</a> on the internet.<br />
</p>

<p>
serialization delay = packet size [bits] / serialization rate [bits / sec] = x seconds<br />
</p>

<p>
\(\text{delay}_{\text{serialization}} = \frac{p}{r_i}\)<br />
</p>

<p>
q: does serialization / deserialization happen at every node?<br />
</p>
</div>
</div>
<div id="outline-container-org25c0871" class="outline-3">
<h3 id="org25c0871">Propagation delay</h3>
<div class="outline-text-3" id="text-org25c0871">
<p>
propagation delay = <a href="edges.html#ID-993f765f-4385-4fcc-a5f6-de5f9a3360ad">link</a> length [m] / propagation rate [m / sec] = x seconds<br />
</p>

<p>
\(\text{delay}_{\text{progagation}} = \frac{l_i}{c}\)<br />
</p>
</div>
</div>
<div id="outline-container-org66c73e9" class="outline-3">
<h3 id="org66c73e9">Queueing delay</h3>
<div class="outline-text-3" id="text-org66c73e9">
<p>
Links are FIFO - first-come, first-serve. Packets that aren&rsquo;t ready to be sent have to wait a bit.<br />
</p>

<p>
This is the one that can be variable &#x2013; sometimes the networks are busy, and your packet has to wait in line.<br />
\(\text{delay}_{\text{queueing}} = Q_i(t)\)<br />
</p>
</div>
</div>
<div id="outline-container-orgb8aafb3" class="outline-3">
<h3 id="orgb8aafb3">End-to-end delay</h3>
<div class="outline-text-3" id="text-orgb8aafb3">
<p>
Sum the serialization + propagation + queueing delays at <i>each</i> link \(i\).<br />
</p>

<p>
\(\text{delay}_{\text{end-to-end}} = \sum_i (\frac{p}{r_i} + \frac{l_i}{c} + Q_i(t))\)<br />
</p>
</div>
</div>
<div id="outline-container-org17a604f" class="outline-3">
<h3 id="org17a604f">Fiber Optic Cable Network</h3>
<div class="outline-text-3" id="text-org17a604f">
<p>
<a href="https://www.reddit.com/r/dataisbeautiful/comments/pt7gu3/earths_submarine_fiber_optic_cable_network_oc/">This</a> is pretty cool.<br />
</p>
</div>
</div>
<div id="outline-container-org7ad236d" class="outline-3">
<h3 id="org7ad236d">Simple model of a router queue</h3>
<div class="outline-text-3" id="text-org7ad236d">
<p>
Q(t): how many in queue<br />
A(t): how many have arrived<br />
D(t): how many have departed<br />
</p>

<p>
Q(t) = A(t) - D(t)<br />
</p>
</div>
</div>
<div id="outline-container-org6220e98" class="outline-3">
<h3 id="org6220e98">Flows</h3>
<div class="outline-text-3" id="text-org6220e98">
<p>
Packets with certain &ldquo;flows&rdquo; are considered higher priority than others.<br />
</p>

<p>
Solution: have several queues of packets. &ldquo;High priority&rdquo; and &ldquo;low priority.&rdquo;<br />
</p>

<p>
Strict priority: always prefer high priority queue<br />
Fair queueing: Packets are sent in the order they <i>would</i> complete in the bit-by-bit scheme.<br />
Most it can be wrong: max length of packet * the rate.<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org52b2d80" class="outline-2">
<h2 id="org52b2d80">Congestion Control</h2>
<div class="outline-text-2" id="text-org52b2d80">
<p>
Capacity on the Internet is shared through &ldquo;congestion control&rdquo; &#x2013; decentralized resource allocation.<br />
</p>
</div>
<div id="outline-container-org88bc5c9" class="outline-3">
<h3 id="org88bc5c9">Why do we need congestion control?</h3>
<div class="outline-text-3" id="text-org88bc5c9">
<p>
TCP provides a <i>flow-controlled</i> bidirectional byte stream. Each sender respects its receiver&rsquo;s capacity. BUT - this doesn&rsquo;t take into account the <i>network&rsquo;s</i> capacity.<br />
</p>

<p>
Here&rsquo;s a simplified diagram of the TCP infrastructure:<br />
</p>
<pre class="example" id="org8759b48">
              [     ]
TCP Sender =&gt; [Queue] [    Link    ] =&gt; TCP Receiver
              [     ]
</pre>


<p>
From sender&rsquo;s POV, 3 places packets can be:<br />
</p>
<ol class="org-ol">
<li>In the queue<br /></li>
<li>On the link<br /></li>
<li>&ldquo;outstanding&rdquo; &#x2013; Got to the receiver, but don&rsquo;t know yet (ack hasn&rsquo;t come back)<br /></li>
</ol>

<p>
The receiver&rsquo;s window size caps the number of &ldquo;outstanding&rdquo; bytes (send but not acked, or judged lost.)<br />
</p>

<p>
<i>What if the receiver has a window size of 1?</i> throughput = 1 byte / round trip time (RTT). Really slow.<br />
<i>What if the receiver has a larger window size?</i> better. window keeps shifting forward as more ackno&rsquo;s are received. not limited by window size, but by the link speed.<br />
</p>

<p>
Bad scenario: slow link from sender to receiver, fast link from receiver to sender, receiver says it has a large window size. The sender will blindly send a bunch of packets, ignoring the fact that the queue will fill up.<br />
</p>

<p>
bad because the queue fills up &#x2013; it&rsquo;s wasteful to send a bit that will later be dropped. (plus if the queue is full no one else can send to the link) =&gt; forcing routers to drop lots of packets, lead to <b>congestion collapse</b>. Lots of demand on the system, but it&rsquo;s not doing useful work.<br />
</p>
</div>
<div id="outline-container-orgb6f5abf" class="outline-4">
<h4 id="orgb6f5abf">Fairness</h4>
<div class="outline-text-4" id="text-orgb6f5abf">
<p>
The previous scenario also represents bad fairness &#x2013; one sender hogs the queue / the useful resources. Any other connection won&rsquo;t be able to send anything.<br />
</p>

<p>
&ldquo;throughput of the byte stream&rdquo; = &ldquo;goodput&rdquo;<br />
</p>

<p>
Different possible resource allocation strategies &#x2013; no &ldquo;right&rdquo; one<br />
</p>

<p>
Goal is to maximize utility.<br />
</p>

<p>
\(\max_{\{x_r\} \in S} \sum_r U_r(x_r)\)<br />
subject to [TODO]<br />
</p>

<p>
If user \(r\) receives throughput \(x_r\), that produced utility \(U_r(x_r)\).<br />
</p>

<p>
Alpha fairness utility function:<br />
\(U(x) = \frac{x^{1- \alpha}}{1 - \alpha}\)<br />
</p>

<p>
\(\alpha = 0\): max utilization<br />
\(\alpha \rightarrow 1\): proportional fairness<br />
\(\alpha = 2\): min-potential-delay fairness<br />
\(\alpha \rightarrow \infty\): max-min fairness<br />
</p>

<p>
Pretty powerful notion. Can use different notions of fairness simply by adjusting \(\alpha\).<br />
</p>

<p>
Other objectives possible: flow completion time, page load time, &ldquo;power&rdquo; = throughput / delay&#x2026;<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org63475eb" class="outline-3">
<h3 id="org63475eb">How to control congestion? - Congestion Window (<code>cwnd</code>)</h3>
<div class="outline-text-3" id="text-org63475eb">
<p>
One way to control congestion:  a <i>second window</i>, in addition to the receiver&rsquo;s advertised window. Sender respects <i>two</i> windows: receiver window, and &ldquo;congestion window&rdquo; <code>cwnd</code>. So&#x2026;how large should the congestion window be??<br />
</p>
</div>
<div id="outline-container-org2556240" class="outline-4">
<h4 id="org2556240">Bandwidth delay product (BDP)</h4>
<div class="outline-text-4" id="text-org2556240">
<p>
Bandwidth delay product (BDP): how much data can be on the link at any moment. We don&rsquo;t want to be sending bytes too fast, or too slow.<br />
</p>

<p>
total number of bytes outstanding - bandwidth x delay product (BDP).<br />
</p>

<ol class="org-ol">
<li>Sender perspective: congestion window basically = bytes in flight (provided decent window size.)<br /></li>
<li>Network perspective: (0 bytes in queue)<br /></li>
<li>Receiver perspective: throughput / goodput (bytes that make it all the way)<br /></li>
</ol>

<p>
Ideal behavior: with N flows, each uses <code>cwnd</code> of BDP / N.<br />
</p>

<p>
How to find the right congestion window?<br />
</p>

<p>
Ideal: Bandwidth delay product<br />
Problem: don&rsquo;t know this stuff at runtime.<br />
</p>

<p>
How to know if congestion window is too small?<br />
</p>
<ul class="org-ul">
<li>if you can increase the window, and all good / throughput goes up.<br /></li>
</ul>
<p>
How to know if congestion window is too big?<br />
</p>
<ul class="org-ul">
<li>if packets are lost.<br /></li>
</ul>
</div>
</div>

<div id="outline-container-orgf4a9a60" class="outline-4">
<h4 id="orgf4a9a60">Additive Increase, Multiplicative Decrease (AIMD)</h4>
<div class="outline-text-4" id="text-orgf4a9a60">
<p>
start with <code>cwnd</code> at a small value.<br />
on <b>success</b>, increase by 1 segment per RTT<br />
on <b>loss</b> (i.e. when queue fills up,) assume congestion. cut <code>cwnd</code> in half.<br />
</p>

<p>
Q: what is the ideal value for the router&rsquo;s buffer (max queue)?<br />
A: BDP. Cuz then the <code>cwnd</code> will get up to 2*BDP, and get cut down to BDP.<br />
Follow-up Q: what if there are a million connections?<br />
A: actually don&rsquo;t need that large of a buffer.<br />
</p>

<p>
Problem: this algorithm depends on the signal of loss to regulate itself. (In this sense, packet loss is actually a good thing. (?!)) But, the issue is, what if the sender never receives a signal of loss?<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org11ff093" class="outline-2">
<h2 id="org11ff093">Routing</h2>
<div class="outline-text-2" id="text-org11ff093">
<p>
Making sure packets from one destination can get to another, along a series of &ldquo;hops.&rdquo;<br />
</p>
</div>
<div id="outline-container-org7725bb7" class="outline-3">
<h3 id="org7725bb7">Routers forward packets <b>one at a time.</b></h3>
<div class="outline-text-3" id="text-org7725bb7">
<p>
Routers look at IP addresses, and send the packet to a router closer to its destination.<br />
</p>
</div>
</div>
<div id="outline-container-org5cab2f3" class="outline-3">
<h3 id="org5cab2f3">How does a router know where to send a packet next?</h3>
<div class="outline-text-3" id="text-org5cab2f3">
<p>
The network topology is super complex. Trees can fall on power lines. Etc.<br />
</p>

<p>
Three ways:<br />
</p>
</div>
<div id="outline-container-orgde78917" class="outline-4">
<h4 id="orgde78917">Flooding: every router sends an arriving packet to every neighbor.</h4>
<div class="outline-text-4" id="text-orgde78917">
<p>
Good thing to do if you don&rsquo;t know anything about the topology: guaranteed to get to its destination (provided that the network graph is connected.)<br />
</p>

<p>
Problem: if there are multiple paths from A to B, there can be multiple packets arriving, cycles, etc. (TTL will eventually stop it from looping, though.). Very inefficient. Packets delivered to everyone.<br />
</p>
</div>
</div>
<div id="outline-container-orgf3b83e2" class="outline-4">
<h4 id="orgf3b83e2">Source routing: end host lists the routers to visit along the way (in the packet itself.)</h4>
<div class="outline-text-4" id="text-orgf3b83e2">
<p>
The packet just has a stack of routers&rsquo; IPs &#x2013; each hop, pop, and send to that router.<br />
</p>

<p>
Was used a lot in the early days of the Internet &#x2013; ISPs didn&rsquo;t want users to be able to source route their own packets. ISPs will block these packets.<br />
</p>

<p>
There are contained situations where source routing makes sense, if you own the entire network.<br />
</p>
</div>
</div>
<div id="outline-container-orgae9cf10" class="outline-4">
<h4 id="orgae9cf10">Distributed algorithm: routers talk to each other, construct forwarding tables using a clever algorithm.</h4>
<div class="outline-text-4" id="text-orgae9cf10">
<p>
<i>How to connect everything?</i><br />
</p>
</div>
<ul class="org-ul">
<li><a id="org52c1e4f"></a>Proto-Idea: let&rsquo;s try a single minimum spanning tree.<br />
<div class="outline-text-5" id="text-org52c1e4f">
<p>
Problems: paths get long, some links unused, need to remember to switch unused links back on<br />
</p>

<p>
Ethernet switches build a single spanning tree between them. (Some links are switched off.)<br />
</p>
</div>
</li>
<li><a id="orgd45c3e5"></a>Better idea: Build a MST <i>for each destination.</i><br />
<div class="outline-text-5" id="text-orgd45c3e5">
<p>
For each destination: a router needs to put an entry in its forwarding table to forward packets along the spanning tree rooted at that destination.<br />
</p>
</div>
</li>
<li><a id="org9973748"></a>How does it know what entry to add?<br />
<ul class="org-ul">
<li><a id="orgb52693a"></a>A1: Assume links have same cost.<br />
<div class="outline-text-6" id="text-orgb52693a">
<p>
Basically: start from the destination node. propagate out from there, keeping track of hop count and (dest node, next hop) at each node..<br />
</p>

<p>
Easy: just wait for the first thing to arrive.<br />
</p>
</div>
</li>
<li><a id="org768c658"></a>What if a link breaks?<br />
<div class="outline-text-6" id="text-org768c658">
<p>
Basically, each node sends out periodic updates.<br />
</p>
</div>
</li>
<li><a id="org2461b94"></a>A2: Different links have different costs.<br />
<div class="outline-text-6" id="text-org2461b94">
<p>
Basically: Dijkstra&rsquo;s.<br />
</p>
</div>
</li>
<li><a id="org60483cb"></a>Distributed Bellman-Ford Algorithm<br />
<div class="outline-text-6" id="text-org60483cb">
<p>
Goal: find min-cost spanning tree to router R.<br />
Assume routers know cost of link to each neighbor.<br />
Router \(R_i\) maintains valueof cost \(C_i\) to reach \(R\), and the next hop.<br />
Vector \(C = (C_1, C_2, ..)\) is the distance vector to \(R\).<br />
Initially, set \(C = (\infty, \infty, ...)\)<br />
</p>
<ol class="org-ol">
<li>After \(T\) seconds, \(R_i\) sends \(C_i\) to neighbors<br /></li>
<li>If \(R_i\) learns of a lower cost path, update \(C_i\) + remember next hop.<br /></li>
<li>Repeat.<br /></li>
</ol>

<p>
Problem: costs don&rsquo;t always get lower. Links break, stuff&rsquo;s unreliable. Algorithm is set up to ignore news like &ldquo;hey, the lowest cost path just went up.&rdquo;<br />
</p>

<p>
Lol, solution: set infinity = 16. If numbers are going out of whack, we&rsquo;ll see that<br />
</p>

<ol class="org-ol">
<li>run time<br /></li>
<li>algorithm converges?<br /></li>
<li>what happens when routers/links fail?<br /></li>
</ol>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org5456639" class="outline-2">
<h2 id="org5456639">Link Layer: Signals into Bits</h2>
</div>
<div id="outline-container-org295d466" class="outline-2">
<h2 id="org295d466">Ethernet</h2>
<div class="outline-text-2" id="text-org295d466">
<p>
Link layer sits at the bottom of the network stack - most often the link layer conforms to  the Ethernet standard.<br />
</p>
</div>
<div id="outline-container-org80bd929" class="outline-3">
<h3 id="org80bd929">Ethernet switches</h3>
<div class="outline-text-3" id="text-org80bd929">
<p>
Recap: packet switch is a generic term for anything that forwards packets hop-by-hop. An Ethernet switch is a different kind of packet switch.<br />
</p>

<pre class="example" id="org2050c2a">
=&gt; [ Lookup address ][ Update Header ] [ Queue Packet ]=&gt;
     ^
     |
     v
   [Forwarding Table]
</pre>
</div>


<div id="outline-container-org4808d9b" class="outline-4 references">
<h4 id="org4808d9b">Links to this node</h4>
<div class="outline-text-4" id="text-org4808d9b">
</div>
<ul class="org-ul">
<li><a id="org0b0d30b"></a><a href="cs144_introduction_to_computer_networking.html#ID-9908ac8d-fadd-4fe6-a78c-c3471cc36ea1">Computer Networking</a><br />
<ul class="org-ul">
<li><a id="org1b09858"></a>(<i>Evolution of the Internet &gt; Level 3: Home Network</i>)<br />
<div class="outline-text-6" id="text-org1b09858">
<p>
&#x2026;it allows us to connect multiple computers to a modem, given an <a href="#org80bd929">Ethernet switch</a>.<br />
</p>
<pre class="example" id="org01138fc">
[TCP/IP/ computer--\                /--router - (...) -Google (e.g.)
 Ethernet]     [switch]           |
              /  |                |
      computer    \               |
                   \              /
         [Ethernet] modem ---- modem
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgb6757ed" class="outline-3">
<h3 id="orgb6757ed">Ethernet Switch does 4 things:</h3>
<div class="outline-text-3" id="text-orgb6757ed">
<ol class="org-ol">
<li>Examine header of each arriving frame.<br /></li>
<li>If the Ethernet Destination Address (aka MAC address) is in the forwarding table, forward the frame to the correct output port(s).<br /></li>
<li>if the Ethernet Destination Address is not in the table, broadcast the frame to <i>all</i> ports (except the one through which the frame arrived.) i.e. flooding.<br /></li>
<li>Entries in the table are <i>learned</i> by checking to see if the Ethernet Source Address of arriving packets are already in the table. If not, add them.<br /></li>
</ol>

<p>
Ethernet learns a spanning tree of the entire network.<br />
</p>
</div>
</div>
<div id="outline-container-org79e7855" class="outline-3">
<h3 id="org79e7855">How Internet routers handle Ethernet packets</h3>
<div class="outline-text-3" id="text-org79e7855">
<ol class="org-ol">
<li>If the Ethernet DA of the arriving frame belongs to the router, accept the frame. else drop.<br /></li>
<li>Examine the IP version number + length of datagram.<br /></li>
<li>Decrement TTL, update IP header checksum.<br /></li>
<li>Check TTL == 0.<br /></li>
<li>If the IP DA is in the forwarding table, forward to the next hop.<br /></li>
<li>Else: If there is a Default Route entry, forward it there, otherwise drop + send ICMP message back to source.<br /></li>
<li>Find Ethernet DA for the next hop router<br /></li>
<li>Create new Ethernet frame + send.<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org82bd61b" class="outline-3">
<h3 id="org82bd61b">Ethernet Frame Format</h3>
<div class="outline-text-3" id="text-org82bd61b">
<ol class="org-ol">
<li>Preamble:<br /></li>
<li>Start of Frame Delimiter:<br /></li>
<li>Destination Address:<br /></li>
<li>Type:<br /></li>
<li>Pad:<br /></li>
<li>Cyclic Redundancy Check:<br /></li>
</ol>
</div>
</div>
<div id="outline-container-org1dd8a8d" class="outline-3">
<h3 id="org1dd8a8d">The origins of Ethernet: sharing a &ldquo;medium&rdquo;</h3>
<div class="outline-text-3" id="text-org1dd8a8d">
<p>
Ethernet is, or at least was originally, an example of multiple hosts sharing a common cable &ldquo;medium&rdquo;. With lots of people trying to talk, we need a protocol so things don&rsquo;t get garbled. More concretely, we need to decide who gets to send, and when.<br />
</p>

<p>
Specific protocol&#x2026;<br />
</p>
</div>
</div>
<div id="outline-container-org15aa3ff" class="outline-3">
<h3 id="org15aa3ff">CSMA/CD Protocol</h3>
<div class="outline-text-3" id="text-org15aa3ff">
<p>
(note: historical - Ethernet doesn&rsquo;t use this anymore b/c we have ethernet switches &#x2013; but wireless protocols are pretty similar to this!)<br />
</p>

<p>
When a host has a packet to transmit:<br />
</p>
<ol class="org-ol">
<li>Carrier Sense: Check if the line is quiet<br /></li>
<li>Collision detection: Detect collision as soon as possible. If a collision is detected, stop transmitting; wait a <i>random time</i> (but an exponentially-backing-off random time), then return to step 1.<br />
(Real life analogy: Sometimes both people start talking at the same time, then go quiet, then both start speaking&#x2026;if you stagger the re-speaking, there&rsquo;s less likely to be collision.)<br /></li>
</ol>
</div>
<div id="outline-container-org7b976f1" class="outline-4">
<h4 id="org7b976f1">CSMA/CD Packet size requirement: why?</h4>
<div class="outline-text-4" id="text-org7b976f1">
<p>
If your transmission is super short, you won&rsquo;t even hear the collision while you&rsquo;re still talking.<br />
</p>

<p>
Solution: packetization time &gt; 2 * propagation delay.<br />
</p>

<p>
\(\frac{P}{R} > \frac{2L}{C}\)<br />
</p>

<p>
\(P \approx 1000\)<br />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbad2ab6" class="outline-2">
<h2 id="orgbad2ab6">Evolution of the Internet</h2>
<div class="outline-text-2" id="text-orgbad2ab6">
<p>
Going up in complexity, here are some possible network configurations.<br />
</p>
</div>
<div id="outline-container-org95f6fd8" class="outline-3">
<h3 id="org95f6fd8">Level 1: Home <a href="#org9806c62">Modem</a></h3>
<div class="outline-text-3" id="text-org95f6fd8">
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span class="org-rainbow-delimiters-depth-1">[</span>TCP/IP<span class="org-rainbow-delimiters-depth-1">]</span> computer--\                /--router - Google <span class="org-rainbow-delimiters-depth-1">(</span>e.g.<span class="org-rainbow-delimiters-depth-1">)</span>
                    \              /
                    modem ---- modem
</pre>
</div>
<p>
We have a pair of socket connected to each other. Sending each other internet datagrams <i>directly</i>.<br />
</p>

<p>
Socket addresses on home computer<br />
local: 18.241.0.5:53050<br />
peer: 172.217.0.36:50<br />
</p>

<p>
Socket addresses at Google:<br />
local: 172.217.0.36:50<br />
peer: 18.241.0.5:53050<br />
</p>

<p>
Totally fine to reuse the same local address, as long as each socket is connected to a different peer address.<br />
</p>

<p>
Problem:<br />
</p>
</div>
</div>
<div id="outline-container-orgcffb896" class="outline-3">
<h3 id="orgcffb896">Level 2: Cable Modem</h3>
<div class="outline-text-3" id="text-orgcffb896">
<p>
Now, the computers and modems talk with Ethernet &#x2013; this means it&rsquo;s faster, but also&#x2026;<br />
</p>

<pre class="example" id="org5d07ad8">
[TCP/IP/ computer--\                /--router - (...) -Google (e.g.)
Ethernet]           \              /
         [Ethernet] modem ---- modem
</pre>
<p>
Benefit of Ethernet network: multiple computers can connect to the modem.<br />
</p>
</div>
</div>
<div id="outline-container-orgbac7034" class="outline-3">
<h3 id="orgbac7034">Level 3: Home Network</h3>
<div class="outline-text-3" id="text-orgbac7034">
<p>
&#x2026;it allows us to connect multiple computers to a modem, given an <a href="#org80bd929">Ethernet switch</a>.<br />
</p>
<pre class="example" id="org3bf55f6">
[TCP/IP/ computer--\                /--router - (...) -Google (e.g.)
 Ethernet]     [switch]           |
              /  |                |
      computer    \               |
                   \              /
         [Ethernet] modem ---- modem
</pre>
</div>
</div>
<div id="outline-container-org4c8fe97" class="outline-3">
<h3 id="org4c8fe97">Level 4: Home Wireless Internet</h3>
<div class="outline-text-3" id="text-org4c8fe97">
<p>
Same thing, but the switch became wireless.<br />
</p>
<pre class="example" id="org3d5bfc4">
[TCP/IP/ computer--\               /--router - (...) -Google (e.g.)
 Ethernet]     [WiFI AP]          |
              /  |                |
      computer    \               |
                   \              /
         [Ethernet] modem ---- modem
</pre>

<p>
Problem: as it stands, ISP has to keep track of all these different computers on their router&#x2026;<br />
</p>
</div>
</div>
<div id="outline-container-org329f5c3" class="outline-3">
<h3 id="org329f5c3">Level 5: Home IPv6 Network</h3>
<div class="outline-text-3" id="text-org329f5c3">
<p>
Solution: have a <i>home network</i> that hinges on a home router. Thus, rather than remembering each individual device, the ISP&rsquo;s router just needs to know which part of the IP hierarchy corresponds to which home router.<br />
</p>
<pre class="example" id="orge534d09">
[TCP/IP/ computer--\                /--router - (...) -Google (e.g.)
 Ethernet]     [Wi-Fi AP]           |
                   \                |
                   [router]         |
                     \              /
         [Ethernet] modem ---- modem
</pre>

<p>
<i>what&rsquo;s the difference between a modem and a router?</i> Modem doesn&rsquo;t know anything about IP: it just translates Ethernet frames to and from electrical signals that can be sent over long distances. Router is thinking about IP, and, well, routing.<br />
</p>

<p>
So&#x2026;this is a good system, and this is basically how it works: for IPv6! But the huge problem with IPv4 is that we don&rsquo;t have enough IP addresses to go around. And, as it stands, the world practically runs on IPv4. So&#x2026;how can we distinguish computers in a home network, without requiring a unique IP for each device?<br />
</p>
</div>
</div>
<div id="outline-container-orge540c03" class="outline-3">
<h3 id="orge540c03">Level 6: TCP Proxy</h3>
<div class="outline-text-3" id="text-orge540c03">
<p>
Here&rsquo;s one potential solution: having one single computer that acts as as a <i>proxy</i> for all the home devices. This proxy will make all the TCP connections <i>for</i> us, and it routes stuff to the individual devices using ports.<br />
</p>

<pre class="example" id="org1120666">
[TCP/IP/ computer--\                 /--router - (...) -Google (e.g.)
 Ethernet]     [Wi-Fi AP]            |
                   \                 |
                   [TCP proxy]       |
                    \                |
                   [router]          |
                     \              /
         [Ethernet] modem ---- modem
</pre>

<p>
Problem: it&rsquo;s annoying to have to manually configure every device to use that specific proxy&#x2026;.<br />
</p>
</div>
</div>
<div id="outline-container-orgf222a63" class="outline-3">
<h3 id="orgf222a63">Level 7: Transparent Proxy</h3>
<div class="outline-text-3" id="text-orgf222a63">
<p>
Solution: Make TCP proxy &ldquo;transparent&rdquo; / &ldquo;pretend&rdquo; to be Google. The proxy acts as a middleman.<br />
</p>
<pre class="example" id="org0fda6b1">
[TCP/IP/ computer--\                /--router - (...) -Google (e.g.)
 Ethernet]     [Wi-Fi AP]
                   \
                   [TCP proxy]
                    \
                   [router]
                     \              /
         [Ethernet] modem ---- modem
</pre>
<p>
<i>Sidenote:</i> Oftentimes, Wi-Fi AP, TCP proxy, router, and modem all in one box.<br />
</p>

<p>
Problem: TCP proxy is burdened with doing non-lightweight TCP stuff, like reassembling byte streams, retransmitting, etc. We wanted the proxy just for its port numbers, not for it to do all the heavy lifting! So, now, moving on to Level 8&#x2026;<br />
</p>
</div>
</div>
<div id="outline-container-org412da13" class="outline-3">
<h3 id="org412da13">Network Address &amp; Port Translation (NAT)</h3>
<div class="outline-text-3" id="text-org412da13">
<p>
NA(P)T <i>doesn&rsquo;t</i> know most of TCP (e.g. reassembling byte stream, ACKs, retransmits) &#x2013; just translates addresses inside TCP segments between local &lt;=&gt; Google.<br />
</p>
<pre class="example" id="orgef5c890">
[TCP/IP/ computer--\                /--router - (...) -Google (e.g.)
 Ethernet]     [Wi-Fi AP]           | [DHCP]
                   \                |
                   [NAPT] [DHCP]    |
                    \               |
                   [router]         |
                     \              /
         [Ethernet] modem ---- modem
</pre>
<p>
NAT mapping: (local, peer) internal &lt;=&gt; (local, peer) external.<br />
</p>

<p>
<i>When is a NAT mapping created?</i> When the local peer initiates the connection (sends SYN.)<br />
<i>Why does it map when local initiates, and not remote?</i> When SYN sent from local, it&rsquo;s fine (many-to-one) but ambiguous when remote sends SYN (Since there are many local devices, and &ldquo;one&rdquo; remote device.)<br />
<i>When is a NAT mapping deleted?</i> NAT mapping deleted when we have a TCP clean shutdown.<br />
NATs can have wildcards: mapping a hierarchy of IP addressses to a remote.<br />
Note: NAT is <i>not</i> a security feature, <i>not</i> a firewall etc.<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org22d4ccb" class="outline-2">
<h2 id="org22d4ccb">Peer-to-peer Networking</h2>
<div class="outline-text-2" id="text-org22d4ccb">
<p>
What happens if we want to connect to another &ldquo;peer,&rdquo; just like us, rather than Google? Problem: if both users are behind a NAT, the mapping can&rsquo;t be created&#x2013; how does it know which computer we&rsquo;re trying to connect to?<br />
</p>

<p>
Solution 1: send everything through a TURN server (or relay or proxy) with a well-provisioned IP address.<br />
</p>

<p>
Solution 2: one of the NATs can have a wildcard rule set up for &ldquo;port forwarding&rdquo; &#x2013; the other computer establishes a connection.<br />
</p>

<p>
Solution 3: NAT traversal. First, learn your IP + port from &ldquo;Google.&rdquo; Then, advertise that to peers. Lol. &ldquo;Google&rdquo; is known as a STUN server. Still need that wildcard entry (permissive NAT) on one peer.<br />
</p>
</div>
</div>
<div id="outline-container-org41c9b86" class="outline-2">
<h2 id="org41c9b86">Internet security</h2>
<div class="outline-text-2" id="text-org41c9b86">
<p>
As of now we haven&rsquo;t discussed any security in the network stack. For that, we add a new layer into the model:<br />
</p>

<p>
Web page<br />
HTTP request / response<br />
<b>Secure byte stream (TLS)</b><br />
Reliable byte stream<br />
Internet datagrams<br />
Ethernet frames<br />
Wave Packets<br />
</p>

<p>
People want to have <b>private</b> communications, and people want to have <b>authenticated</b> communications.<br />
</p>

<p>
Lots of people (especially governments) want to listen in on your traffic.<br />
</p>
</div>
<div id="outline-container-orga768a70" class="outline-3">
<h3 id="orga768a70">Authenticated Encryption with Associated Data - AEAD</h3>
<div class="outline-text-3" id="text-orga768a70">
<p>
<code>encrypt(counter, key, plaintext) =&gt; ciphertext + tag</code><br />
</p>

<p>
<code>counter</code>: number that never repeats<br />
<code>key</code>: random 256-bit number<br />
<code>plaintext</code>: any bytes<br />
</p>

<p>
<code>ciphertext</code>: same length as plaintext (but gibberish)<br />
<code>tag</code>: short (256-bit authenticator that proves the message is legit)<br />
</p>

<p>
Key idea: two parties that have nothing to do with each other can agree on a random key.<br />
</p>

<p>
Useful because we want to connect securely to &ldquo;strangers&rdquo; (e.g. buying something on Amazon) all the time.<br />
</p>
</div>
</div>
<div id="outline-container-org44e234a" class="outline-3">
<h3 id="org44e234a">Public-key encryption</h3>
<div class="outline-text-3" id="text-org44e234a">
<p>
Each person has a public key and a private key that are mathematically related to each other (take an encryption class.) They announce their public keys to the world, and they can send each other a message that <i>only the other can read</i> since they encrypt it using the peer&rsquo;s public key, and the peer has the corresponding private key.<br />
</p>

<p>
There are organizations that &ldquo;certify&rdquo; that a certain public key really belongs to a certain entity. Then the key gets &ldquo;signed&rdquo; by that authority.<br />
</p>
</div>
</div>
</div>


<div id="outline-container-orgef3a7ac" class="outline-2 references">
<h2 id="orgef3a7ac">Links to this node</h2>
<div class="outline-text-2" id="text-orgef3a7ac">
</div>
<div id="outline-container-org3ab5091" class="outline-3">
<h3 id="org3ab5091"><a href="cs224w_machine_learning_with_graphs.html#ID-da69965b-ad50-45ad-9e81-b8593e7de09e">Why Graphs?</a></h3>
<div class="outline-text-3" id="text-org3ab5091">
</div>
<div id="outline-container-orge80caf5" class="outline-4">
<h4 id="orge80caf5">(<i>Introduction &gt; Why Graphs?</i>)</h4>
<div class="outline-text-4" id="text-orge80caf5">
<p>
<a href="graphs.html#ID-5705ba04-b296-4446-824b-3551d7bd8a09">Graphs</a> are a general language for describing and analyzing entities with relationships/interactions. Many domains have a natural relational structure, that lends themselves to a graph <a href="representations.html#ID-c7ba956c-67ad-4b8e-9c7f-f18bc1b2b4ff">representation</a>:<br />
</p>
<ul class="org-ul">
<li>Physical roads, bridges, tunnels connecting places. 🚗<br /></li>
<li>Particles, based on their proximities. ⚛️<br /></li>
<li>Animals in a food ecosystem. 🕸<br /></li>
<li><a href="cs144_introduction_to_computer_networking.html#ID-9908ac8d-fadd-4fe6-a78c-c3471cc36ea1">Computer networks</a>. 💻<br /></li>
<li>Knowledge graphs, scene graphs, code graphs&#x2026;<br /></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga2cbbfb" class="outline-3">
<h3 id="orga2cbbfb"><a href="index.html#ID-23e03a28-48b1-4fa3-9fa3-71a369950c6d">Ketan&rsquo;s Nebula</a></h3>
<div class="outline-text-3" id="text-orga2cbbfb">
<svg display="block" style="margin: auto;" width="240px" height="240px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="Gradient1">
      <stop class="stop1" offset="0%"/>
      <stop class="stop2" offset="100%"/>
    </linearGradient>
    <style type="text/css"><![CDATA[
      .beaker { fill: url(#Gradient1); }
      .stop1 { stop-color: #50cf42; }
      .stop2 { stop-color: #4eb8ca; }
    ]]></style>
  </defs>
  <circle r="8" cx="8" cy="8" fill="#bb00bb" opacity="0.4"/>
  <circle r="8" cx="12" cy="12" fill="#bb0000" opacity="0.4"/>
  <circle r="8" cx="16" cy="16" fill="#0000bb" opacity="0.4"/>
</svg>

<p>
<a href="philosophy.html#ID-091329e5-7896-4975-b88b-99b30f4dd482">philosophy</a><br />
<a href="shortcuts.html#ID-058bef0b-aba6-4ac6-b4ae-b3c7b7e22040">shortcuts</a><br />
<a href="programming.html#ID-0997b060-ee05-458e-beed-3494675c879d">programming</a><br />
<a href="social_psychology.html#ID-3db1ed04-4b29-46cf-9940-1afd30d5d25f">Social Psychology</a><br />
<a href="cs152_trust_and_safety_engineering.html#ID-0e008aa4-63a2-4ae3-8c59-933b3065d721">Trust and Safety Engineering</a><br />
<a href="cs144_introduction_to_computer_networking.html#ID-9908ac8d-fadd-4fe6-a78c-c3471cc36ea1">Computer Networking</a><br />
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p>Made with <span class="heart">♥</span> using
<a href="https://orgmode.org/">org-mode</a>.
Source code is available
<a href="https://github.com/ketan0/digital-laboratory">here</a>.</p>
<script src="popper.min.js"></script>
<script src="tippy-bundle.umd.min.js"></script>
<script src="tooltips.js"></script>
</div>
</body>
</html>
