<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-03-25 Fri 01:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>context</title>
<meta name="author" content="Ketan Agrawal" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="syntax.css" />
<link rel="stylesheet" type="text/css" href="styles.css" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
<link rel="manifest" href="/site.webmanifest" />
</head>
<body>
<div id="preamble" class="status">
<a style="color: inherit; text-decoration: none" href="/"><img src="nebula-logo.svg" width="50px"></a>
</div>
<div id="content" class="content">
<h1 class="title">context</h1>


<div id="outline-container-org616809c" class="outline-2 references">
<h2 id="org616809c">Links to this node</h2>
<div class="outline-text-2" id="text-org616809c">
</div>
<div id="outline-container-orgf091938" class="outline-3">
<h3 id="orgf091938"><a href="musings.html#ID-e2ff4d71-a630-4a8d-94d4-66606f321bd4">musings</a></h3>
</div>
</div>

<div id="outline-container-org3ea2a7b" class="outline-2">
<h2 id="org3ea2a7b">The best approach to implementing anything this <a href="complexity.html#ID-9648399a-daf3-44a0-8612-a3d84b99d0c1">complex</a> is to invent a collection of milestones that advance you toward your final goal. &#x2013;advice from Jerry Cain</h2>
<div class="outline-text-2" id="text-org3ea2a7b">
</div>
<div id="outline-container-org02dbed5" class="outline-3">
<h3 id="org02dbed5"><a href="emacs.html#ID-1999996d-b676-4fc4-894b-caf82f8dd7ff">emacs</a></h3>
</div>

<div id="outline-container-orgb5dad30" class="outline-3">
<h3 id="orgb5dad30"><a href="programming_bottom_up.html#ID-95ff3fb3-f886-41df-9f4f-5f9223b4ca4e">Programming Bottom-Up</a></h3>
<div class="outline-text-3" id="text-orgb5dad30">
<p>
<a href="http://www.paulgraham.com/progbot.html">http://www.paulgraham.com/progbot.html</a><br />
</p>

<p>
There are two ways of <a href="programming.html#ID-0997b060-ee05-458e-beed-3494675c879d">programming</a> in Lisp &#x2013; top-down, and bottom-up.<br />
</p>

<p>
Top-down = the classic paradigm of divide-and conquer, decomposing the problem hierarchically into smaller problems.<br />
</p>

<p>
Bottom-up = defining your own DSL in Lisp, and using those primitives to make something cool.<br />
</p>

<p>
Most programming is done top-down, but with the powers of macros you can go bottom-up, creating "little universes" in Lisp&#x2026;<br />
</p>

<p>
Personally what comes to mind is the <code>rx</code> macro in emacs. It's like a nice little domain-specific language for writing regular expressions, embedded right into elisp.<br />
</p>

<p>
Regexp matching a block comment in C:<br />
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp" data-language="emacs-lisp">(<span class="org-keyword">rx</span> <span class="org-string">"/*"</span>                          <span class="org-comment-delimiter">; </span><span class="org-comment">Initial /*</span>
    (zero-or-more
     (<span class="org-keyword">or</span> (not (any <span class="org-string">"*"</span>))          <span class="org-comment-delimiter">;  </span><span class="org-comment">Either non-*,</span>
         (seq <span class="org-string">"*"</span>                 <span class="org-comment-delimiter">;  </span><span class="org-comment">or * followed by</span>
              (not (any <span class="org-string">"/"</span>)))))  <span class="org-comment-delimiter">;  </span><span class="org-comment">non-/</span>
    (one-or-more <span class="org-string">"*"</span>)             <span class="org-comment-delimiter">; </span><span class="org-comment">At least one star,</span>
    <span class="org-string">"/"</span>)                          <span class="org-comment-delimiter">; </span><span class="org-comment">and the final /</span>
</pre>
</div>

<pre class="example">
/\*\(?:[^*]\|\*[^/]\)*\*+/
</pre>


<p>
you redefine <i>the language itself</i> to have the primitives you want it to have, and then you can proceed to build something (perhaps in top-down fashion now.) It's like "meeting in the middle," so you don't have to build up super complex primitives, and you don't have to decompose down to a super fine-grained level.<br />
</p>

<p>
I wonder what the connection between this bottom-up paradigm and Bret Victor - The Future of Programming is. I feel like maybe there's an idea that his visual programming playgrounds are like a domain-specific language (albeit not in Lisp.) They give the user a powerful set of primitives to manipulate digital objects, and the user can then build from there to make it come to life.<br />
</p>

<p>
Also feel like <a href="emacs.html#ID-1999996d-b676-4fc4-894b-caf82f8dd7ff">emacs</a> encourages bottom-up programming in some ways, well ofc because of Lisp, but also because of the interactivity of the environment. You write a snippet, and immediately you can evaluate that code and test out your snippet. You get a couple more snippets, try those out, and then it's like, ok cool, what else can I build with these snippets?<br />
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p>Made with <span class="heart">â™¥</span> using
<a href="https://orgmode.org/">org-mode</a>.
Source code is available
<a href="https://github.com/ketan0/digital-laboratory">here</a>.</p>
<script src="popper.min.js"></script>
<script src="tippy-bundle.umd.min.js"></script>
<script src="tooltips.js"></script>
<script src="dark-themes.js"></script>
</div>
</body>
</html>
